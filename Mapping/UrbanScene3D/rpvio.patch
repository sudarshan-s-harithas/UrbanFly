From 3d295e1ff4c292ce203e636f363520f9b633908c Mon Sep 17 00:00:00 2001
From: Karnik Ram <karnikram@gmail.com>
Date: Thu, 17 Sep 2020 12:22:47 +0530
Subject: [PATCH 01/42] Add code for homography-based initializatin

---
 vins_estimator/src/estimator.cpp          | 14 ++--
 vins_estimator/src/initial/solve_5pts.cpp | 80 ++++++++++++++++++-----
 vins_estimator/src/initial/solve_5pts.h   |  6 +-
 3 files changed, 73 insertions(+), 27 deletions(-)

diff --git a/vins_estimator/src/estimator.cpp b/vins_estimator/src/estimator.cpp
index cb7a4af..46c93ef 100644
--- a/vins_estimator/src/estimator.cpp
+++ b/vins_estimator/src/estimator.cpp
@@ -491,14 +491,16 @@ bool Estimator::relativeHPose(Matrix3d &relative_R, Vector3d &relative_T, int &l
             }
             average_parallax = 1.0 * sum_parallax / int(corres.size());
 
-            MatrixXd::Identity(4,4) TrIC; 
-            TrIC.block(0, 0, 3, 3) = RIC;
-            TrIC.col(3) = TIC;
+            Matrix4d TrIC = Matrix4d::Identity(); 
+            TrIC.block(0, 0, 3, 3) = RIC[0];
+            TrIC.block(0,3,3,0) = TIC[0];
 
-            //compute preintegrated rotation
-            
+            //compute corresponding preintegrated rotation
+            Matrix3d R_imu = Matrix3d::Identity();
+            for(int k = WINDOW_SIZE - 1; k > i; k--)
+                R_imu = R_imu * (pre_integrations[k]->delta_q).toRotationMatrix();
 
-            if(average_parallax * 660 > 30 && m_estimator.solveRelativeHRT(corres, relative_R, relative_T, R_imu, TrIC))
+            if(average_parallax * 660 > 30 && m_estimator.solveRelativeHRT(corres, R_imu, TrIC, relative_R, relative_T))
             {
                 l = i;
                 ROS_DEBUG("average_parallax %f choose l %d and newest frame to triangulate the whole structure", average_parallax * 460, l);
diff --git a/vins_estimator/src/initial/solve_5pts.cpp b/vins_estimator/src/initial/solve_5pts.cpp
index a1c170d..61440da 100644
--- a/vins_estimator/src/initial/solve_5pts.cpp
+++ b/vins_estimator/src/initial/solve_5pts.cpp
@@ -1,4 +1,5 @@
 #include "solve_5pts.h"
+#include <algorithm>
 
 
 namespace cv {
@@ -241,27 +242,70 @@ bool MotionEstimator::solveRelativeHRT(const vector<pair<Vector3d, Vector3d>> &c
         cv::Mat H = cv::findHomography(ll, rr, cv::RANSAC, 0.3/665);
         cv::Mat K = (cv::Mat_<double>(3, 3) << 1, 0, 0, 0, 1, 0, 0, 0, 1);
 
-        decomposeH(H, K, R_imu, TIC);
-
-        Eigen::Matrix3d R;
-        Eigen::Vector3d T;
-        for (int i = 0; i < 3; i++)
-        {   
-            T(i) = trans.at<double>(i, 0);
-            for (int j = 0; j < 3; j++)
-                R(i, j) = rot.at<double>(i, j);
-        }
-
-        Rotation = R.transpose();
-        Translation = -R.transpose() * T;
-        if(inlier_cnt > 12)
-            return true;
-        else
-            return false;
+        Eigen::Matrix4d Tr = decomposeH(H, K, R_imu, TrIC);
+        Rotation = Tr.block(0,0,3,3);
+        Translation = Tr.block(0,3,3,0);
+        return true;
     }
     return false;
 }
 
-void MotionEstimator::decomposeH(const cv::Mat &H, const cv::Mat &K, const Matrix3d &R_imu, const Matrix4d &TrIC)
+Matrix4d MotionEstimator::decomposeH(const cv::Mat &H, const cv::Mat &K, const Matrix3d &R_imu, const Matrix4d &TrIC)
 {
+    vector<cv::Mat> cv_Rs, cv_ts, cv_ns;
+    int n_sols = cv::decomposeHomographyMat(H, K, cv_Rs, cv_ts, cv_ns);
+
+    vector<Matrix4d> positive_depth_transforms;
+    if(n_sols > 1)
+    {
+        for(int i = 0; i < n_sols; i++)
+        {
+            Matrix4d Tr = Matrix4d::Identity();
+            Matrix3d R;
+            cv::cv2eigen(cv_Rs[i], R);
+            Tr.block(0,0,3,3) = R;
+
+            Vector3d t;
+            cv::cv2eigen(cv_ts[i], t);
+            Tr.block(0,3,3,0) = t;
+
+            //Tr = TrIC * Tr * TrIC.inverse();
+            Tr = Tr.inverse();
+
+            Vector3d e3(0, 0, 1);
+            Vector3d n;
+            cv::cv2eigen(cv_ns[i], n);
+            if(n.dot(e3) > 0)
+                positive_depth_transforms.push_back(Tr);
+        }
+
+        vector<double> rot_diff;
+        for(size_t i = 0; i < positive_depth_transforms.size(); i++)
+        {
+            Eigen::Matrix4d Tr = TrIC * positive_depth_transforms[i] * TrIC.inverse();
+            Eigen::Matrix3d R = Tr.block(0,0,3,3);
+            double f = (R.transpose()*R_imu - MatrixXd::Identity(3,3)).norm();
+            rot_diff.push_back(f);
+        }
+
+        int min_index = std::min_element(rot_diff.begin(), rot_diff.end()) - rot_diff.begin();
+        Matrix4d Tr = positive_depth_transforms[min_index];
+        return Tr;
+    }
+
+    else
+    {
+        Matrix4d Tr = Matrix4d::Identity();
+        Matrix3d R;
+        cv::cv2eigen(cv_Rs[0], R);
+        Tr.block(0,0,3,3) = R;
+
+        Vector3d t;
+        cv::cv2eigen(cv_ts[0], t);
+        Tr.block(0,3,3,0) = t;
+
+        //Tr = TrIC * Tr * TrIC.inverse();
+        Tr = Tr.inverse();
+        return Tr;
+    }
 }
diff --git a/vins_estimator/src/initial/solve_5pts.h b/vins_estimator/src/initial/solve_5pts.h
index 3e95c9e..9fb118e 100644
--- a/vins_estimator/src/initial/solve_5pts.h
+++ b/vins_estimator/src/initial/solve_5pts.h
@@ -4,8 +4,8 @@
 using namespace std;
 
 #include <opencv2/opencv.hpp>
-//#include <opencv2/core/eigen.hpp>
 #include <eigen3/Eigen/Dense>
+#include <opencv2/core/eigen.hpp>
 using namespace Eigen;
 
 #include <ros/console.h>
@@ -15,8 +15,8 @@ class MotionEstimator
   public:
 
     bool solveRelativeRT(const vector<pair<Vector3d, Vector3d>> &corres, Matrix3d &R, Vector3d &T);
-    bool solveRelativeHRT(const vector<pair<Vector3d, Vector3d>> &corres, const Matrix3d &R_imu, const Matrix4d &TrIC, const Matrix3d &R, Vector3d &T);
-    void decomposeH(const cv::Mat &H, const cv::Mat &K, const Matrix3d &R_imu, const  Matrix4d &TrIC);
+    bool solveRelativeHRT(const vector<pair<Vector3d, Vector3d>> &corres, const Matrix3d &R_imu, const Matrix4d &TrIC, Matrix3d &R, Vector3d &T);
+    Matrix4d decomposeH(const cv::Mat &H, const cv::Mat &K, const Matrix3d &R_imu, const  Matrix4d &TrIC);
 
   private:
     double testTriangulation(const vector<cv::Point2f> &l,
-- 
2.17.1


From 56f9ef55ba6caf95001bba4e8cd34524fd79a089 Mon Sep 17 00:00:00 2001
From: Karnik Ram <karnikram@gmail.com>
Date: Thu, 17 Sep 2020 14:19:09 +0530
Subject: [PATCH 02/42] Fix runtime errors

---
 vins_estimator/src/estimator.cpp          |  4 ++--
 vins_estimator/src/initial/solve_5pts.cpp | 10 +++++-----
 2 files changed, 7 insertions(+), 7 deletions(-)

diff --git a/vins_estimator/src/estimator.cpp b/vins_estimator/src/estimator.cpp
index 46c93ef..733a968 100644
--- a/vins_estimator/src/estimator.cpp
+++ b/vins_estimator/src/estimator.cpp
@@ -492,8 +492,8 @@ bool Estimator::relativeHPose(Matrix3d &relative_R, Vector3d &relative_T, int &l
             average_parallax = 1.0 * sum_parallax / int(corres.size());
 
             Matrix4d TrIC = Matrix4d::Identity(); 
-            TrIC.block(0, 0, 3, 3) = RIC[0];
-            TrIC.block(0,3,3,0) = TIC[0];
+            TrIC.block(0,0,3,3) = ric[0];
+            TrIC.block(0,3,3,1) = tic[0];
 
             //compute corresponding preintegrated rotation
             Matrix3d R_imu = Matrix3d::Identity();
diff --git a/vins_estimator/src/initial/solve_5pts.cpp b/vins_estimator/src/initial/solve_5pts.cpp
index 61440da..6be2bf1 100644
--- a/vins_estimator/src/initial/solve_5pts.cpp
+++ b/vins_estimator/src/initial/solve_5pts.cpp
@@ -244,7 +244,7 @@ bool MotionEstimator::solveRelativeHRT(const vector<pair<Vector3d, Vector3d>> &c
 
         Eigen::Matrix4d Tr = decomposeH(H, K, R_imu, TrIC);
         Rotation = Tr.block(0,0,3,3);
-        Translation = Tr.block(0,3,3,0);
+        Translation = Tr.block(0,3,3,1);
         return true;
     }
     return false;
@@ -267,10 +267,10 @@ Matrix4d MotionEstimator::decomposeH(const cv::Mat &H, const cv::Mat &K, const M
 
             Vector3d t;
             cv::cv2eigen(cv_ts[i], t);
-            Tr.block(0,3,3,0) = t;
+            Tr.block(0,3,3,1) = t;
 
             //Tr = TrIC * Tr * TrIC.inverse();
-            Tr = Tr.inverse();
+            Tr = Tr.inverse().eval();
 
             Vector3d e3(0, 0, 1);
             Vector3d n;
@@ -302,10 +302,10 @@ Matrix4d MotionEstimator::decomposeH(const cv::Mat &H, const cv::Mat &K, const M
 
         Vector3d t;
         cv::cv2eigen(cv_ts[0], t);
-        Tr.block(0,3,3,0) = t;
+        Tr.block(0,3,3,1) = t;
 
         //Tr = TrIC * Tr * TrIC.inverse();
-        Tr = Tr.inverse();
+        Tr = Tr.inverse().eval();
         return Tr;
     }
 }
-- 
2.17.1


From f9db6ec5f6d62bc608e5acd96c45414f384eadc4 Mon Sep 17 00:00:00 2001
From: Karnik Ram <karnikram@gmail.com>
Date: Sat, 19 Sep 2020 08:21:32 +0530
Subject: [PATCH 03/42] Reject with H

---
 feature_tracker/src/feature_tracker.cpp   | 3 ++-
 vins_estimator/src/initial/solve_5pts.cpp | 3 +++
 2 files changed, 5 insertions(+), 1 deletion(-)

diff --git a/feature_tracker/src/feature_tracker.cpp b/feature_tracker/src/feature_tracker.cpp
index d33709c..41322b8 100644
--- a/feature_tracker/src/feature_tracker.cpp
+++ b/feature_tracker/src/feature_tracker.cpp
@@ -188,7 +188,8 @@ void FeatureTracker::rejectWithF()
         }
 
         vector<uchar> status;
-        cv::findFundamentalMat(un_cur_pts, un_forw_pts, cv::FM_RANSAC, F_THRESHOLD, 0.99, status);
+        //cv::findFundamentalMat(un_cur_pts, un_forw_pts, cv::FM_RANSAC, F_THRESHOLD, 0.99, status);
+        cv::findHomography(un_cur_pts, un_forw_pts, cv::RANSAC, 3, status);
         int size_a = cur_pts.size();
         reduceVector(prev_pts, status);
         reduceVector(cur_pts, status);
diff --git a/vins_estimator/src/initial/solve_5pts.cpp b/vins_estimator/src/initial/solve_5pts.cpp
index 6be2bf1..50999c3 100644
--- a/vins_estimator/src/initial/solve_5pts.cpp
+++ b/vins_estimator/src/initial/solve_5pts.cpp
@@ -227,6 +227,7 @@ bool MotionEstimator::solveRelativeRT(const vector<pair<Vector3d, Vector3d>> &co
     return false;
 }
 
+
 bool MotionEstimator::solveRelativeHRT(const vector<pair<Vector3d, Vector3d>> &corres, const Matrix3d &R_imu, const Matrix4d &TrIC, Matrix3d &Rotation, Vector3d &Translation)
 {
     if (corres.size() >= 15)
@@ -241,6 +242,7 @@ bool MotionEstimator::solveRelativeHRT(const vector<pair<Vector3d, Vector3d>> &c
         //cv::Mat E = cv::findFundamentalMat(ll, rr, cv::FM_RANSAC, 0.3 / 460, 0.99, mask);
         cv::Mat H = cv::findHomography(ll, rr, cv::RANSAC, 0.3/665);
         cv::Mat K = (cv::Mat_<double>(3, 3) << 1, 0, 0, 0, 1, 0, 0, 0, 1);
+        //cv::Mat K = (cv::Mat_<double>(3,3) << 665, 0, 511, 0, 665, 383, 0, 0, 1);
 
         Eigen::Matrix4d Tr = decomposeH(H, K, R_imu, TrIC);
         Rotation = Tr.block(0,0,3,3);
@@ -250,6 +252,7 @@ bool MotionEstimator::solveRelativeHRT(const vector<pair<Vector3d, Vector3d>> &c
     return false;
 }
 
+
 Matrix4d MotionEstimator::decomposeH(const cv::Mat &H, const cv::Mat &K, const Matrix3d &R_imu, const Matrix4d &TrIC)
 {
     vector<cv::Mat> cv_Rs, cv_ts, cv_ns;
-- 
2.17.1


From 64247beda4b05f162fbec72127dd1f79bade8709 Mon Sep 17 00:00:00 2001
From: Karnik Ram <karnikram@gmail.com>
Date: Tue, 22 Sep 2020 10:39:26 +0530
Subject: [PATCH 04/42] Add code for homography-constrained visual BA for init

---
 vins_estimator/src/estimator.cpp           |  11 +-
 vins_estimator/src/estimator.h             |   2 +-
 vins_estimator/src/initial/initial_sfm.cpp | 216 ++++++++++++++++++++-
 vins_estimator/src/initial/initial_sfm.h   |  40 +++-
 vins_estimator/src/initial/solve_5pts.cpp  |  27 ++-
 vins_estimator/src/initial/solve_5pts.h    |   4 +-
 6 files changed, 280 insertions(+), 20 deletions(-)

diff --git a/vins_estimator/src/estimator.cpp b/vins_estimator/src/estimator.cpp
index 733a968..c561fd6 100644
--- a/vins_estimator/src/estimator.cpp
+++ b/vins_estimator/src/estimator.cpp
@@ -267,15 +267,16 @@ bool Estimator::initialStructure()
     } 
     Matrix3d relative_R;
     Vector3d relative_T;
+    Vector3d n;
     int l;
-    if (!relativeHPose(relative_R, relative_T, l))
+    if (!relativeHPose(relative_R, relative_T, n, l))
     {
         ROS_INFO("Not enough features or parallax; Move device around");
         return false;
     }
     GlobalSFM sfm;
-    if(!sfm.construct(frame_count + 1, Q, T, l,
-              relative_R, relative_T,
+    if(!sfm.constructH(frame_count + 1, Q, T, l,
+              relative_R, relative_T, n,
               sfm_f, sfm_tracked_points))
     {
         ROS_DEBUG("global SFM failed!");
@@ -470,7 +471,7 @@ bool Estimator::relativePose(Matrix3d &relative_R, Vector3d &relative_T, int &l)
     return false;
 }
 
-bool Estimator::relativeHPose(Matrix3d &relative_R, Vector3d &relative_T, int &l)
+bool Estimator::relativeHPose(Matrix3d &relative_R, Vector3d &relative_T, Vector3d &n, int &l)
 {
     // find previous frame which contains enough correspondence and parallex with newest frame
     for (int i = 0; i < WINDOW_SIZE; i++)
@@ -500,7 +501,7 @@ bool Estimator::relativeHPose(Matrix3d &relative_R, Vector3d &relative_T, int &l
             for(int k = WINDOW_SIZE - 1; k > i; k--)
                 R_imu = R_imu * (pre_integrations[k]->delta_q).toRotationMatrix();
 
-            if(average_parallax * 660 > 30 && m_estimator.solveRelativeHRT(corres, R_imu, TrIC, relative_R, relative_T))
+            if(average_parallax * 660 > 30 && m_estimator.solveRelativeHRT(corres, R_imu, TrIC, relative_R, relative_T, n))
             {
                 l = i;
                 ROS_DEBUG("average_parallax %f choose l %d and newest frame to triangulate the whole structure", average_parallax * 460, l);
diff --git a/vins_estimator/src/estimator.h b/vins_estimator/src/estimator.h
index 7f912da..9b2a731 100644
--- a/vins_estimator/src/estimator.h
+++ b/vins_estimator/src/estimator.h
@@ -40,7 +40,7 @@ class Estimator
     bool initialStructure();
     bool visualInitialAlign();
     bool relativePose(Matrix3d &relative_R, Vector3d &relative_T, int &l);
-    bool relativeHPose(Matrix3d &relative_R, Vector3d &relative_T, int &l);
+    bool relativeHPose(Matrix3d &relative_R, Vector3d &relative_T, Vector3d &n, int &l);
     void slideWindow();
     void solveOdometry();
     void slideWindowNew();
diff --git a/vins_estimator/src/initial/initial_sfm.cpp b/vins_estimator/src/initial/initial_sfm.cpp
index 6fbcc17..c7b1661 100644
--- a/vins_estimator/src/initial/initial_sfm.cpp
+++ b/vins_estimator/src/initial/initial_sfm.cpp
@@ -280,11 +280,11 @@ bool GlobalSFM::construct(int frame_num, Quaterniond* q, Vector3d* T, int l,
 	//std::cout << summary.BriefReport() << "\n";
 	if (summary.termination_type == ceres::CONVERGENCE || summary.final_cost < 5e-03)
 	{
-		//cout << "vision only BA converge" << endl;
+		cout << "vision only BA converge" << endl;
 	}
 	else
 	{
-		//cout << "vision only BA not converge " << endl;
+		cout << "vision only BA not converge " << endl;
 		return false;
 	}
 	for (int i = 0; i < frame_num; i++)
@@ -311,3 +311,215 @@ bool GlobalSFM::construct(int frame_num, Quaterniond* q, Vector3d* T, int l,
 
 }
 
+
+bool GlobalSFM::constructH(int frame_num, Quaterniond* q, Vector3d* T, int l,
+			  const Matrix3d relative_R, const Vector3d relative_T, const Vector3d n,
+			  vector<SFMFeature> &sfm_f, map<int, Vector3d> &sfm_tracked_points)
+{
+	feature_num = sfm_f.size();
+	//cout << "set 0 and " << l << " as known " << endl;
+	// have relative_r relative_t
+	// intial two view
+	q[l].w() = 1;
+	q[l].x() = 0;
+	q[l].y() = 0;
+	q[l].z() = 0;
+	T[l].setZero();
+	q[frame_num - 1] = q[l] * Quaterniond(relative_R);
+	T[frame_num - 1] = relative_T;
+	//cout << "init q_l " << q[l].w() << " " << q[l].vec().transpose() << endl;
+	//cout << "init t_l " << T[l].transpose() << endl;
+
+	//rotate to cam frame
+	Matrix3d c_Rotation[frame_num];
+	Vector3d c_Translation[frame_num];
+	Quaterniond c_Quat[frame_num];
+	double c_rotation[frame_num][4];
+	double c_translation[frame_num][3];
+    double c_normal[3];
+	Eigen::Matrix<double, 3, 4> Pose[frame_num];
+
+	c_Quat[l] = q[l].inverse();
+	c_Rotation[l] = c_Quat[l].toRotationMatrix();
+	c_Translation[l] = -1 * (c_Rotation[l] * T[l]);
+	Pose[l].block<3, 3>(0, 0) = c_Rotation[l];
+	Pose[l].block<3, 1>(0, 3) = c_Translation[l];
+
+	c_Quat[frame_num - 1] = q[frame_num - 1].inverse();
+	c_Rotation[frame_num - 1] = c_Quat[frame_num - 1].toRotationMatrix();
+	c_Translation[frame_num - 1] = -1 * (c_Rotation[frame_num - 1] * T[frame_num - 1]);
+	Pose[frame_num - 1].block<3, 3>(0, 0) = c_Rotation[frame_num - 1];
+	Pose[frame_num - 1].block<3, 1>(0, 3) = c_Translation[frame_num - 1];
+
+	//1: trangulate between l ----- frame_num - 1
+	//2: solve pnp l + 1; trangulate l + 1 ------- frame_num - 1; 
+	for (int i = l; i < frame_num - 1 ; i++)
+	{
+		// solve pnp
+		if (i > l)
+		{
+			Matrix3d R_initial = c_Rotation[i - 1];
+			Vector3d P_initial = c_Translation[i - 1];
+			if(!solveFrameByPnP(R_initial, P_initial, i, sfm_f))
+				return false;
+			c_Rotation[i] = R_initial;
+			c_Translation[i] = P_initial;
+			c_Quat[i] = c_Rotation[i];
+			Pose[i].block<3, 3>(0, 0) = c_Rotation[i];
+			Pose[i].block<3, 1>(0, 3) = c_Translation[i];
+		}
+
+		// triangulate point based on the solve pnp result
+		triangulateTwoFrames(i, Pose[i], frame_num - 1, Pose[frame_num - 1], sfm_f);
+	}
+	//3: triangulate l-----l+1 l+2 ... frame_num -2
+	for (int i = l + 1; i < frame_num - 1; i++)
+		triangulateTwoFrames(l, Pose[l], i, Pose[i], sfm_f);
+	//4: solve pnp l-1; triangulate l-1 ----- l
+	//             l-2              l-2 ----- l
+	for (int i = l - 1; i >= 0; i--)
+	{
+		//solve pnp
+		Matrix3d R_initial = c_Rotation[i + 1];
+		Vector3d P_initial = c_Translation[i + 1];
+		if(!solveFrameByPnP(R_initial, P_initial, i, sfm_f))
+			return false;
+		c_Rotation[i] = R_initial;
+		c_Translation[i] = P_initial;
+		c_Quat[i] = c_Rotation[i];
+		Pose[i].block<3, 3>(0, 0) = c_Rotation[i];
+		Pose[i].block<3, 1>(0, 3) = c_Translation[i];
+		//triangulate
+		triangulateTwoFrames(i, Pose[i], l, Pose[l], sfm_f);
+	}
+	//5: triangulate all other points
+	for (int j = 0; j < feature_num; j++)
+	{
+		if (sfm_f[j].state == true)
+			continue;
+		if ((int)sfm_f[j].observation.size() >= 2)
+		{
+			Vector2d point0, point1;
+			int frame_0 = sfm_f[j].observation[0].first;
+			point0 = sfm_f[j].observation[0].second;
+			int frame_1 = sfm_f[j].observation.back().first;
+			point1 = sfm_f[j].observation.back().second;
+			Vector3d point_3d;
+			triangulatePoint(Pose[frame_0], Pose[frame_1], point0, point1, point_3d);
+			sfm_f[j].state = true;
+			sfm_f[j].position[0] = point_3d(0);
+			sfm_f[j].position[1] = point_3d(1);
+			sfm_f[j].position[2] = point_3d(2);
+			//cout << "trangulated : " << frame_0 << " " << frame_1 << "  3d point : "  << j << "  " << point_3d.transpose() << endl;
+		}		
+	}
+
+/*
+	for (int i = 0; i < frame_num; i++)
+	{
+		q[i] = c_Rotation[i].transpose(); 
+		cout << "solvePnP  q" << " i " << i <<"  " <<q[i].w() << "  " << q[i].vec().transpose() << endl;
+	}
+	for (int i = 0; i < frame_num; i++)
+	{
+		Vector3d t_tmp;
+		t_tmp = -1 * (q[i] * c_Translation[i]);
+		cout << "solvePnP  t" << " i " << i <<"  " << t_tmp.x() <<"  "<< t_tmp.y() <<"  "<< t_tmp.z() << endl;
+	}
+*/
+	//full BA
+	ceres::Problem problem;
+	ceres::LocalParameterization* local_parameterization = new ceres::QuaternionParameterization();
+	//cout << " begin full BA " << endl;
+	for (int i = 0; i < frame_num; i++)
+	{
+		//double array for ceres
+		c_translation[i][0] = c_Translation[i].x();
+		c_translation[i][1] = c_Translation[i].y();
+		c_translation[i][2] = c_Translation[i].z();
+		c_rotation[i][0] = c_Quat[i].w();
+		c_rotation[i][1] = c_Quat[i].x();
+		c_rotation[i][2] = c_Quat[i].y();
+		c_rotation[i][3] = c_Quat[i].z();
+		problem.AddParameterBlock(c_rotation[i], 4, local_parameterization);
+		problem.AddParameterBlock(c_translation[i], 3);
+		if (i == l)
+		{
+			problem.SetParameterBlockConstant(c_rotation[i]);
+		}
+		if (i == l || i == frame_num - 1)
+		{
+			problem.SetParameterBlockConstant(c_translation[i]);
+		}
+	}
+
+    c_normal[0] = n[0];
+    c_normal[1] = n[1];
+    c_normal[2] = n[2];
+    problem.AddParameterBlock(c_normal, 3);
+
+	for (int i = 0; i < feature_num; i++)
+	{
+		if (sfm_f[i].state != true)
+			continue;
+		for (int j = 0; j < int(sfm_f[i].observation.size()); j++)
+		{
+			int l = sfm_f[i].observation[j].first;
+            
+			ceres::CostFunction* b_cost_function = ReprojectionError3D::Create(
+												sfm_f[i].observation[j].second.x(),
+												sfm_f[i].observation[j].second.y());
+
+    		problem.AddResidualBlock(b_cost_function, NULL, c_rotation[l], c_translation[l],
+    								sfm_f[i].position);	 
+
+			ceres::CostFunction* h_cost_function = ReprojectionErrorH::Create(
+												sfm_f[i].observation[j].second.x(),
+												sfm_f[i].observation[j].second.y());
+
+    		problem.AddResidualBlock(h_cost_function, NULL, c_rotation[l], c_translation[l],c_normal, 
+    								sfm_f[i].position);	 
+		}
+
+	}
+	ceres::Solver::Options options;
+	options.linear_solver_type = ceres::DENSE_SCHUR;
+	//options.minimizer_progress_to_stdout = true;
+	options.max_solver_time_in_seconds = 0.2;
+	ceres::Solver::Summary summary;
+	ceres::Solve(options, &problem, &summary);
+	//std::cout << summary.BriefReport() << "\n";
+	if (summary.termination_type == ceres::CONVERGENCE || summary.final_cost < 5e-03)
+	{
+		cout << "vision only BA converge" << endl;
+	}
+	else
+	{
+		cout << "vision only BA not converge " << endl;
+		return false;
+	}
+	for (int i = 0; i < frame_num; i++)
+	{
+		q[i].w() = c_rotation[i][0]; 
+		q[i].x() = c_rotation[i][1]; 
+		q[i].y() = c_rotation[i][2]; 
+		q[i].z() = c_rotation[i][3]; 
+		q[i] = q[i].inverse();
+		//cout << "final  q" << " i " << i <<"  " <<q[i].w() << "  " << q[i].vec().transpose() << endl;
+	}
+	for (int i = 0; i < frame_num; i++)
+	{
+
+		T[i] = -1 * (q[i] * Vector3d(c_translation[i][0], c_translation[i][1], c_translation[i][2]));
+		//cout << "final  t" << " i " << i <<"  " << T[i](0) <<"  "<< T[i](1) <<"  "<< T[i](2) << endl;
+	}
+	for (int i = 0; i < (int)sfm_f.size(); i++)
+	{
+		if(sfm_f[i].state)
+			sfm_tracked_points[sfm_f[i].id] = Vector3d(sfm_f[i].position[0], sfm_f[i].position[1], sfm_f[i].position[2]);
+	}
+	return true;
+
+}
+
+
diff --git a/vins_estimator/src/initial/initial_sfm.h b/vins_estimator/src/initial/initial_sfm.h
index f70432d..a1e6854 100644
--- a/vins_estimator/src/initial/initial_sfm.h
+++ b/vins_estimator/src/initial/initial_sfm.h
@@ -53,6 +53,40 @@ struct ReprojectionError3D
 	double observed_v;
 };
 
+
+struct ReprojectionErrorH
+{
+	ReprojectionErrorH(double observed_u, double observed_v)
+		:observed_u(observed_u), observed_v(observed_v)
+		{}
+
+	template <typename T>
+	bool operator()(const T* const R, const T* const t, const T* const n, const T* point, T* residuals) const
+	{
+		T p[3];
+        ceres::QuaternionRotatePoint(R, point, p);
+        T np = n[0] * point[0] + n[1] * point[1] + n[2] * point[2];
+        p[0] += t[0]*np; p[1] += t[1]*np; p[2] += t[2]*np;
+		T xp = p[0] / p[2];
+    	T yp = p[1] / p[2];
+    	residuals[0] = xp - T(observed_u);
+    	residuals[1] = yp - T(observed_v);
+    	return true;
+	}
+
+	static ceres::CostFunction* Create(const double observed_x,
+	                                   const double observed_y) 
+	{
+	  return (new ceres::AutoDiffCostFunction<
+	          ReprojectionErrorH, 2, 4, 3, 3, 3>(
+	          	new ReprojectionErrorH(observed_x,observed_y)));
+	}
+
+	double observed_u;
+	double observed_v;
+};
+
+
 class GlobalSFM
 {
 public:
@@ -61,6 +95,10 @@ public:
 			  const Matrix3d relative_R, const Vector3d relative_T,
 			  vector<SFMFeature> &sfm_f, map<int, Vector3d> &sfm_tracked_points);
 
+    bool constructH(int frame_num, Quaterniond* q, Vector3d* T, int l,
+			  const Matrix3d relative_R, const Vector3d relative_T, const Vector3d n,
+			  vector<SFMFeature> &sfm_f, map<int, Vector3d> &sfm_tracked_points);
+
 private:
 	bool solveFrameByPnP(Matrix3d &R_initial, Vector3d &P_initial, int i, vector<SFMFeature> &sfm_f);
 
@@ -71,4 +109,4 @@ private:
 							  vector<SFMFeature> &sfm_f);
 
 	int feature_num;
-};
\ No newline at end of file
+};
diff --git a/vins_estimator/src/initial/solve_5pts.cpp b/vins_estimator/src/initial/solve_5pts.cpp
index 50999c3..bdc87a3 100644
--- a/vins_estimator/src/initial/solve_5pts.cpp
+++ b/vins_estimator/src/initial/solve_5pts.cpp
@@ -228,7 +228,7 @@ bool MotionEstimator::solveRelativeRT(const vector<pair<Vector3d, Vector3d>> &co
 }
 
 
-bool MotionEstimator::solveRelativeHRT(const vector<pair<Vector3d, Vector3d>> &corres, const Matrix3d &R_imu, const Matrix4d &TrIC, Matrix3d &Rotation, Vector3d &Translation)
+bool MotionEstimator::solveRelativeHRT(const vector<pair<Vector3d, Vector3d>> &corres, const Matrix3d &R_imu, const Matrix4d &TrIC, Matrix3d &Rotation, Vector3d &Translation, Vector3d &n)
 {
     if (corres.size() >= 15)
     {
@@ -244,21 +244,26 @@ bool MotionEstimator::solveRelativeHRT(const vector<pair<Vector3d, Vector3d>> &c
         cv::Mat K = (cv::Mat_<double>(3, 3) << 1, 0, 0, 0, 1, 0, 0, 0, 1);
         //cv::Mat K = (cv::Mat_<double>(3,3) << 665, 0, 511, 0, 665, 383, 0, 0, 1);
 
-        Eigen::Matrix4d Tr = decomposeH(H, K, R_imu, TrIC);
-        Rotation = Tr.block(0,0,3,3);
-        Translation = Tr.block(0,3,3,1);
+        Eigen::Matrix4d est_Tr;
+        Eigen::Vector3d est_n;
+        decomposeH(H, K, R_imu, TrIC, est_Tr, est_n);
+        Rotation = est_Tr.block(0,0,3,3);
+        Translation = est_Tr.block(0,3,3,1);
+        n = est_n;
         return true;
     }
     return false;
 }
 
 
-Matrix4d MotionEstimator::decomposeH(const cv::Mat &H, const cv::Mat &K, const Matrix3d &R_imu, const Matrix4d &TrIC)
+void MotionEstimator::decomposeH(const cv::Mat &H, const cv::Mat &K, const Matrix3d &R_imu, const Matrix4d &TrIC, Matrix4d &est_Tr, Vector3d &est_n)
 {
     vector<cv::Mat> cv_Rs, cv_ts, cv_ns;
     int n_sols = cv::decomposeHomographyMat(H, K, cv_Rs, cv_ts, cv_ns);
 
     vector<Matrix4d> positive_depth_transforms;
+    vector<Vector3d> positive_depth_normals;
+
     if(n_sols > 1)
     {
         for(int i = 0; i < n_sols; i++)
@@ -280,6 +285,7 @@ Matrix4d MotionEstimator::decomposeH(const cv::Mat &H, const cv::Mat &K, const M
             cv::cv2eigen(cv_ns[i], n);
             if(n.dot(e3) > 0)
                 positive_depth_transforms.push_back(Tr);
+                positive_depth_normals.push_back(n);
         }
 
         vector<double> rot_diff;
@@ -292,8 +298,8 @@ Matrix4d MotionEstimator::decomposeH(const cv::Mat &H, const cv::Mat &K, const M
         }
 
         int min_index = std::min_element(rot_diff.begin(), rot_diff.end()) - rot_diff.begin();
-        Matrix4d Tr = positive_depth_transforms[min_index];
-        return Tr;
+        est_Tr = positive_depth_transforms[min_index];
+        est_n = positive_depth_normals[min_index];
     }
 
     else
@@ -307,8 +313,11 @@ Matrix4d MotionEstimator::decomposeH(const cv::Mat &H, const cv::Mat &K, const M
         cv::cv2eigen(cv_ts[0], t);
         Tr.block(0,3,3,1) = t;
 
+        Vector3d n;
+        cv::cv2eigen(cv_ns[0], n);
+
         //Tr = TrIC * Tr * TrIC.inverse();
-        Tr = Tr.inverse().eval();
-        return Tr;
+        est_Tr = Tr.inverse().eval();
+        est_n = n;
     }
 }
diff --git a/vins_estimator/src/initial/solve_5pts.h b/vins_estimator/src/initial/solve_5pts.h
index 9fb118e..f090370 100644
--- a/vins_estimator/src/initial/solve_5pts.h
+++ b/vins_estimator/src/initial/solve_5pts.h
@@ -15,8 +15,8 @@ class MotionEstimator
   public:
 
     bool solveRelativeRT(const vector<pair<Vector3d, Vector3d>> &corres, Matrix3d &R, Vector3d &T);
-    bool solveRelativeHRT(const vector<pair<Vector3d, Vector3d>> &corres, const Matrix3d &R_imu, const Matrix4d &TrIC, Matrix3d &R, Vector3d &T);
-    Matrix4d decomposeH(const cv::Mat &H, const cv::Mat &K, const Matrix3d &R_imu, const  Matrix4d &TrIC);
+    bool solveRelativeHRT(const vector<pair<Vector3d, Vector3d>> &corres, const Matrix3d &R_imu, const Matrix4d &TrIC, Matrix3d &R, Vector3d &T, Vector3d &n);
+    void decomposeH(const cv::Mat &H, const cv::Mat &K, const Matrix3d &R_imu, const  Matrix4d &TrIC, Matrix4d &est_Tr, Vector3d &est_n);
 
   private:
     double testTriangulation(const vector<cv::Point2f> &l,
-- 
2.17.1


From fb6f3cf6cf15d5119c170b55e86ca5784773f970 Mon Sep 17 00:00:00 2001
From: Karnik Ram <karnikram@gmail.com>
Date: Wed, 23 Sep 2020 08:12:13 +0530
Subject: [PATCH 05/42] Fix parameter bugs

---
 vins_estimator/src/initial/initial_sfm.cpp | 15 +++++++++++----
 vins_estimator/src/initial/initial_sfm.h   |  1 +
 2 files changed, 12 insertions(+), 4 deletions(-)

diff --git a/vins_estimator/src/initial/initial_sfm.cpp b/vins_estimator/src/initial/initial_sfm.cpp
index c7b1661..05917a0 100644
--- a/vins_estimator/src/initial/initial_sfm.cpp
+++ b/vins_estimator/src/initial/initial_sfm.cpp
@@ -104,6 +104,9 @@ void GlobalSFM::triangulateTwoFrames(int frame0, Eigen::Matrix<double, 3, 4> &Po
 			sfm_f[j].position[0] = point_3d(0);
 			sfm_f[j].position[1] = point_3d(1);
 			sfm_f[j].position[2] = point_3d(2);
+            sfm_f[j].image[0] = point1[0];
+            sfm_f[j].image[1] = point1[1];
+            sfm_f[j].image[2] = 1;
 			//cout << "trangulated : " << frame1 << "  3d point : "  << j << "  " << point_3d.transpose() << endl;
 		}							  
 	}
@@ -212,6 +215,9 @@ bool GlobalSFM::construct(int frame_num, Quaterniond* q, Vector3d* T, int l,
 			sfm_f[j].position[0] = point_3d(0);
 			sfm_f[j].position[1] = point_3d(1);
 			sfm_f[j].position[2] = point_3d(2);
+            sfm_f[j].image[0] = point1[0];
+            sfm_f[j].image[1] = point1[1];
+            sfm_f[j].image[2] = 1;
 			//cout << "trangulated : " << frame_0 << " " << frame_1 << "  3d point : "  << j << "  " << point_3d.transpose() << endl;
 		}		
 	}
@@ -410,6 +416,9 @@ bool GlobalSFM::constructH(int frame_num, Quaterniond* q, Vector3d* T, int l,
 			sfm_f[j].position[0] = point_3d(0);
 			sfm_f[j].position[1] = point_3d(1);
 			sfm_f[j].position[2] = point_3d(2);
+            sfm_f[j].image[0] = point1[0];
+            sfm_f[j].image[1] = point1[1];
+            sfm_f[j].image[2] = 1;
 			//cout << "trangulated : " << frame_0 << " " << frame_1 << "  3d point : "  << j << "  " << point_3d.transpose() << endl;
 		}		
 	}
@@ -471,16 +480,14 @@ bool GlobalSFM::constructH(int frame_num, Quaterniond* q, Vector3d* T, int l,
 												sfm_f[i].observation[j].second.y());
 
     		problem.AddResidualBlock(b_cost_function, NULL, c_rotation[l], c_translation[l],
-    								sfm_f[i].position);	 
+    								sfm_f[i].position); 
 
 			ceres::CostFunction* h_cost_function = ReprojectionErrorH::Create(
 												sfm_f[i].observation[j].second.x(),
 												sfm_f[i].observation[j].second.y());
 
-    		problem.AddResidualBlock(h_cost_function, NULL, c_rotation[l], c_translation[l],c_normal, 
-    								sfm_f[i].position);	 
+    		problem.AddResidualBlock(h_cost_function, NULL, c_rotation[l], c_translation[l], c_normal, sfm_f[i].image);
 		}
-
 	}
 	ceres::Solver::Options options;
 	options.linear_solver_type = ceres::DENSE_SCHUR;
diff --git a/vins_estimator/src/initial/initial_sfm.h b/vins_estimator/src/initial/initial_sfm.h
index a1e6854..7780732 100644
--- a/vins_estimator/src/initial/initial_sfm.h
+++ b/vins_estimator/src/initial/initial_sfm.h
@@ -19,6 +19,7 @@ struct SFMFeature
     int id;
     vector<pair<int,Vector2d>> observation;
     double position[3];
+    double image[3]; // u v 1
     double depth;
 };
 
-- 
2.17.1


From d33f9314e26d538f07fdb97cc6278b5a4f449b41 Mon Sep 17 00:00:00 2001
From: Karnik Ram <karnikram@gmail.com>
Date: Thu, 1 Oct 2020 11:11:06 +0530
Subject: [PATCH 06/42] Add homography const functor into estimator

---
 vins_estimator/src/estimator.cpp              |  5 +-
 vins_estimator/src/estimator.h                |  2 +
 vins_estimator/src/factor/homography_factor.h | 47 +++++++++++++++++++
 vins_estimator/src/initial/initial_sfm.cpp    |  7 ++-
 vins_estimator/src/initial/initial_sfm.h      |  4 +-
 5 files changed, 61 insertions(+), 4 deletions(-)
 create mode 100644 vins_estimator/src/factor/homography_factor.h

diff --git a/vins_estimator/src/estimator.cpp b/vins_estimator/src/estimator.cpp
index c561fd6..97a3821 100644
--- a/vins_estimator/src/estimator.cpp
+++ b/vins_estimator/src/estimator.cpp
@@ -435,7 +435,7 @@ bool Estimator::visualInitialAlign()
         Vs[i] = rot_diff * Vs[i];
     }
     ROS_DEBUG_STREAM("g0     " << g.transpose());
-    ROS_DEBUG_STREAM("my R0  " << Utility::R2ypr(Rs[0]).transpose()); 
+    ROS_DEBUG_STREAM("my R0  " << Utility::R2ypr(Rs[0]).transpose());
 
     return true;
 }
@@ -800,6 +800,9 @@ void Estimator::optimization()
             {
                 ProjectionFactor *f = new ProjectionFactor(pts_i, pts_j);
                 problem.AddResidualBlock(f, loss_function, para_Pose[imu_i], para_Pose[imu_j], para_Ex_Pose[0], para_Feature[feature_index]);
+
+                ceres::CostFunction *h_cost_function = HomographyFactor::Create(pts_i, pts_j);
+                problem.AddResidualBlock(h_cost_function, loss_function, para_Pose[imu_i], para_Pose[imu_j], para_N, para_Ex_Pose[0]);
             }
             f_m_cnt++;
         }
diff --git a/vins_estimator/src/estimator.h b/vins_estimator/src/estimator.h
index 9b2a731..f3feedf 100644
--- a/vins_estimator/src/estimator.h
+++ b/vins_estimator/src/estimator.h
@@ -17,6 +17,7 @@
 #include "factor/projection_factor.h"
 #include "factor/projection_td_factor.h"
 #include "factor/marginalization_factor.h"
+#include "factor/homography_factor.h"
 
 #include <unordered_map>
 #include <queue>
@@ -114,6 +115,7 @@ class Estimator
     double para_Retrive_Pose[SIZE_POSE];
     double para_Td[1][1];
     double para_Tr[1][1];
+    double para_N[3];
 
     int loop_window_index;
 
diff --git a/vins_estimator/src/factor/homography_factor.h b/vins_estimator/src/factor/homography_factor.h
new file mode 100644
index 0000000..86b03ff
--- /dev/null
+++ b/vins_estimator/src/factor/homography_factor.h
@@ -0,0 +1,47 @@
+#pragma once
+#include <ceres/ceres.h>
+#include <eigen3/Eigen/Dense>
+
+struct HomographyFactor
+{
+    HomographyFactor(const Eigen::Vector3d &_pts_i, const Eigen::Vector3d &_pts_j) : pts_i(_pts_i), pts_j(_pts_j) {}
+
+    template <typename T>
+        bool operator()(const T* const pose_i, const T* const pose_j, const T* const para_n, const T* const ex_pose, 
+        T* residuals) const
+        {
+            Eigen::Map<const Eigen::Matrix<T, 3, 1>> pi(pose_i);
+            Eigen::Quaternion<T> qi;
+            qi.coeffs() << pose_i[3], pose_i[4], pose_i[5], pose_i[6];
+
+            Eigen::Map<const Eigen::Matrix<T, 3, 1>> pj(pose_j);
+            Eigen::Quaternion<T> qj;
+            qj.coeffs() << pose_j[3], pose_j[4], pose_j[5], pose_j[6];
+
+            Eigen::Map<const Eigen::Matrix<T, 3, 1>> tic(ex_pose);
+            Eigen::Quaternion<T> qic;
+            qic.coeffs() << ex_pose[3], ex_pose[4], ex_pose[5], ex_pose[6];
+
+            Eigen::Map<const Eigen::Matrix<T, 3, 1>> n(para_n);
+
+            Eigen::Quaternion<T> qji = qj.inverse() * qi;
+            Eigen::Matrix<T, 3, 1> tji = qj.inverse().toRotationMatrix() * (pi - pj);
+            Eigen::Matrix<T, 3, 1> pts_imu_i = qic * pts_i.cast<T>() + tic;
+            Eigen::Matrix<T, 3, 1> pts_imu_j = qji * pts_imu_i + tji * n.transpose() * pts_imu_i;
+            Eigen::Matrix<T, 3, 1> pts_cam_j = qic.inverse() * (pts_imu_j - tic);
+
+            pts_cam_j = (pts_cam_j / pts_cam_j[2]);
+            residuals[0] = pts_cam_j[0] - pts_j[0];
+            residuals[1] = pts_cam_j[1] - pts_j[1];
+
+            return true;
+        }
+
+    static ceres::CostFunction* Create(const Eigen::Vector3d &_pts_i, const Eigen::Vector3d &_pts_j)
+    {
+        return (new ceres::AutoDiffCostFunction<HomographyFactor, 2, 7, 7, 3, 7>
+                (new HomographyFactor(_pts_i, _pts_j)));
+    }
+
+    Eigen::Vector3d pts_i, pts_j;
+};
diff --git a/vins_estimator/src/initial/initial_sfm.cpp b/vins_estimator/src/initial/initial_sfm.cpp
index 05917a0..76a4f88 100644
--- a/vins_estimator/src/initial/initial_sfm.cpp
+++ b/vins_estimator/src/initial/initial_sfm.cpp
@@ -319,7 +319,7 @@ bool GlobalSFM::construct(int frame_num, Quaterniond* q, Vector3d* T, int l,
 
 
 bool GlobalSFM::constructH(int frame_num, Quaterniond* q, Vector3d* T, int l,
-			  const Matrix3d relative_R, const Vector3d relative_T, const Vector3d n,
+			  const Matrix3d relative_R, const Vector3d relative_T, Vector3d &n,
 			  vector<SFMFeature> &sfm_f, map<int, Vector3d> &sfm_tracked_points)
 {
 	feature_num = sfm_f.size();
@@ -525,6 +525,11 @@ bool GlobalSFM::constructH(int frame_num, Quaterniond* q, Vector3d* T, int l,
 		if(sfm_f[i].state)
 			sfm_tracked_points[sfm_f[i].id] = Vector3d(sfm_f[i].position[0], sfm_f[i].position[1], sfm_f[i].position[2]);
 	}
+
+    n[0] = c_normal[0];
+    n[1] = c_normal[1];
+    n[2] = c_normal[2];
+
 	return true;
 
 }
diff --git a/vins_estimator/src/initial/initial_sfm.h b/vins_estimator/src/initial/initial_sfm.h
index 7780732..e79dcea 100644
--- a/vins_estimator/src/initial/initial_sfm.h
+++ b/vins_estimator/src/initial/initial_sfm.h
@@ -1,4 +1,4 @@
-#pragma once 
+#pragma once
 #include <ceres/ceres.h>
 #include <ceres/rotation.h>
 #include <eigen3/Eigen/Dense>
@@ -97,7 +97,7 @@ public:
 			  vector<SFMFeature> &sfm_f, map<int, Vector3d> &sfm_tracked_points);
 
     bool constructH(int frame_num, Quaterniond* q, Vector3d* T, int l,
-			  const Matrix3d relative_R, const Vector3d relative_T, const Vector3d n,
+			  const Matrix3d relative_R, const Vector3d relative_T, Vector3d &n,
 			  vector<SFMFeature> &sfm_f, map<int, Vector3d> &sfm_tracked_points);
 
 private:
-- 
2.17.1


From d3d1faeaa37f6b413622e6b3373c80cffc4182f7 Mon Sep 17 00:00:00 2001
From: Karnik Ram <karnikram@gmail.com>
Date: Thu, 1 Oct 2020 11:57:44 +0530
Subject: [PATCH 07/42] Add code for transforming normal vector

---
 vins_estimator/src/estimator.cpp              | 3 +++
 vins_estimator/src/factor/homography_factor.h | 5 ++++-
 2 files changed, 7 insertions(+), 1 deletion(-)

diff --git a/vins_estimator/src/estimator.cpp b/vins_estimator/src/estimator.cpp
index 97a3821..0112bcd 100644
--- a/vins_estimator/src/estimator.cpp
+++ b/vins_estimator/src/estimator.cpp
@@ -283,6 +283,9 @@ bool Estimator::initialStructure()
         marginalization_flag = MARGIN_OLD;
         return false;
     }
+    para_N[0] = n[0];
+    para_N[1] = n[1];
+    para_N[2] = n[2];
 
     //solve pnp for all frame
     map<double, ImageFrame>::iterator frame_it;
diff --git a/vins_estimator/src/factor/homography_factor.h b/vins_estimator/src/factor/homography_factor.h
index 86b03ff..8473930 100644
--- a/vins_estimator/src/factor/homography_factor.h
+++ b/vins_estimator/src/factor/homography_factor.h
@@ -23,11 +23,14 @@ struct HomographyFactor
             qic.coeffs() << ex_pose[3], ex_pose[4], ex_pose[5], ex_pose[6];
 
             Eigen::Map<const Eigen::Matrix<T, 3, 1>> n(para_n);
+            Eigen::Matrix<T, 3, 1> n_imu_1 = qic*(n.normalized()) + tic;
+            Eigen::Matrix<T, 3, 1> n_imu_i = qi.inverse()*n_imu_1 - qi.inverse()*pi;
+            Eigen::Matrix<T, 3, 1> n_cam_i = qic.inverse()*n_imu_i - qic.inverse()*tic;
 
             Eigen::Quaternion<T> qji = qj.inverse() * qi;
             Eigen::Matrix<T, 3, 1> tji = qj.inverse().toRotationMatrix() * (pi - pj);
             Eigen::Matrix<T, 3, 1> pts_imu_i = qic * pts_i.cast<T>() + tic;
-            Eigen::Matrix<T, 3, 1> pts_imu_j = qji * pts_imu_i + tji * n.transpose() * pts_imu_i;
+            Eigen::Matrix<T, 3, 1> pts_imu_j = qji * pts_imu_i + tji * n_cam_i.transpose() * pts_imu_i;
             Eigen::Matrix<T, 3, 1> pts_cam_j = qic.inverse() * (pts_imu_j - tic);
 
             pts_cam_j = (pts_cam_j / pts_cam_j[2]);
-- 
2.17.1


From dbbe91b1f26b80fe235e3f7dfee9a55c98f108ad Mon Sep 17 00:00:00 2001
From: Karnik Ram <karnikram@gmail.com>
Date: Fri, 2 Oct 2020 10:27:49 +0530
Subject: [PATCH 08/42] Change to pixel coordinates in h cost functor

---
 vins_estimator/src/estimator.cpp | 6 +++++-
 1 file changed, 5 insertions(+), 1 deletion(-)

diff --git a/vins_estimator/src/estimator.cpp b/vins_estimator/src/estimator.cpp
index 0112bcd..6f31fb5 100644
--- a/vins_estimator/src/estimator.cpp
+++ b/vins_estimator/src/estimator.cpp
@@ -774,6 +774,7 @@ void Estimator::optimization()
         int imu_i = it_per_id.start_frame, imu_j = imu_i - 1;
         
         Vector3d pts_i = it_per_id.feature_per_frame[0].point;
+        Vector3d img_pts_i(it_per_id.feature_per_frame[0].uv.x(), it_per_id.feature_per_frame[1].uv.y(), 1);
 
         for (auto &it_per_frame : it_per_id.feature_per_frame)
         {
@@ -782,7 +783,10 @@ void Estimator::optimization()
             {
                 continue;
             }
+
             Vector3d pts_j = it_per_frame.point;
+            Vector3d img_pts_j(it_per_frame.uv.x(), it_per_frame.uv.y(), 1);
+
             if (ESTIMATE_TD)
             {
                     ProjectionTdFactor *f_td = new ProjectionTdFactor(pts_i, pts_j, it_per_id.feature_per_frame[0].velocity, it_per_frame.velocity,
@@ -804,7 +808,7 @@ void Estimator::optimization()
                 ProjectionFactor *f = new ProjectionFactor(pts_i, pts_j);
                 problem.AddResidualBlock(f, loss_function, para_Pose[imu_i], para_Pose[imu_j], para_Ex_Pose[0], para_Feature[feature_index]);
 
-                ceres::CostFunction *h_cost_function = HomographyFactor::Create(pts_i, pts_j);
+                ceres::CostFunction *h_cost_function = HomographyFactor::Create(img_pts_i, img_pts_j);
                 problem.AddResidualBlock(h_cost_function, loss_function, para_Pose[imu_i], para_Pose[imu_j], para_N, para_Ex_Pose[0]);
             }
             f_m_cnt++;
-- 
2.17.1


From 9cfa806aac4f59176a59e778e3570c4e69ebb1d2 Mon Sep 17 00:00:00 2001
From: Karnik Ram <karnikram@gmail.com>
Date: Fri, 2 Oct 2020 12:21:06 +0530
Subject: [PATCH 09/42] Fix reference frame bug

---
 vins_estimator/src/factor/homography_factor.h | 5 ++---
 1 file changed, 2 insertions(+), 3 deletions(-)

diff --git a/vins_estimator/src/factor/homography_factor.h b/vins_estimator/src/factor/homography_factor.h
index 8473930..2a35d40 100644
--- a/vins_estimator/src/factor/homography_factor.h
+++ b/vins_estimator/src/factor/homography_factor.h
@@ -25,12 +25,11 @@ struct HomographyFactor
             Eigen::Map<const Eigen::Matrix<T, 3, 1>> n(para_n);
             Eigen::Matrix<T, 3, 1> n_imu_1 = qic*(n.normalized()) + tic;
             Eigen::Matrix<T, 3, 1> n_imu_i = qi.inverse()*n_imu_1 - qi.inverse()*pi;
-            Eigen::Matrix<T, 3, 1> n_cam_i = qic.inverse()*n_imu_i - qic.inverse()*tic;
 
             Eigen::Quaternion<T> qji = qj.inverse() * qi;
-            Eigen::Matrix<T, 3, 1> tji = qj.inverse().toRotationMatrix() * (pi - pj);
+            Eigen::Matrix<T, 3, 1> tji = qj.inverse() * (pi - pj);
             Eigen::Matrix<T, 3, 1> pts_imu_i = qic * pts_i.cast<T>() + tic;
-            Eigen::Matrix<T, 3, 1> pts_imu_j = qji * pts_imu_i + tji * n_cam_i.transpose() * pts_imu_i;
+            Eigen::Matrix<T, 3, 1> pts_imu_j = qji * pts_imu_i + tji * n_imu_i.transpose() * pts_imu_i;
             Eigen::Matrix<T, 3, 1> pts_cam_j = qic.inverse() * (pts_imu_j - tic);
 
             pts_cam_j = (pts_cam_j / pts_cam_j[2]);
-- 
2.17.1


From 80c091ccbffd376f8bef7f19c1129f47d321e8c2 Mon Sep 17 00:00:00 2001
From: Karnik Ram <karnikram@gmail.com>
Date: Fri, 2 Oct 2020 12:39:00 +0530
Subject: [PATCH 10/42] Fix indexing bug

---
 vins_estimator/src/estimator.cpp | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/vins_estimator/src/estimator.cpp b/vins_estimator/src/estimator.cpp
index 6f31fb5..141ba1c 100644
--- a/vins_estimator/src/estimator.cpp
+++ b/vins_estimator/src/estimator.cpp
@@ -774,7 +774,7 @@ void Estimator::optimization()
         int imu_i = it_per_id.start_frame, imu_j = imu_i - 1;
         
         Vector3d pts_i = it_per_id.feature_per_frame[0].point;
-        Vector3d img_pts_i(it_per_id.feature_per_frame[0].uv.x(), it_per_id.feature_per_frame[1].uv.y(), 1);
+        Vector3d img_pts_i(it_per_id.feature_per_frame[0].uv.x(), it_per_id.feature_per_frame[0].uv.y(), 1);
 
         for (auto &it_per_frame : it_per_id.feature_per_frame)
         {
-- 
2.17.1


From 608edba769955088a250ac4ac416a5f8bb766588 Mon Sep 17 00:00:00 2001
From: Karnik Ram <karnikram@gmail.com>
Date: Sat, 3 Oct 2020 11:21:59 +0530
Subject: [PATCH 11/42] Change to point values in cost functor

---
 vins_estimator/src/estimator.cpp | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/vins_estimator/src/estimator.cpp b/vins_estimator/src/estimator.cpp
index 141ba1c..096ef10 100644
--- a/vins_estimator/src/estimator.cpp
+++ b/vins_estimator/src/estimator.cpp
@@ -808,7 +808,7 @@ void Estimator::optimization()
                 ProjectionFactor *f = new ProjectionFactor(pts_i, pts_j);
                 problem.AddResidualBlock(f, loss_function, para_Pose[imu_i], para_Pose[imu_j], para_Ex_Pose[0], para_Feature[feature_index]);
 
-                ceres::CostFunction *h_cost_function = HomographyFactor::Create(img_pts_i, img_pts_j);
+                ceres::CostFunction *h_cost_function = HomographyFactor::Create(pts_i, pts_j);
                 problem.AddResidualBlock(h_cost_function, loss_function, para_Pose[imu_i], para_Pose[imu_j], para_N, para_Ex_Pose[0]);
             }
             f_m_cnt++;
-- 
2.17.1


From 55e116d9bfa5350e2e717a758fcd9dd1dfa7d0f9 Mon Sep 17 00:00:00 2001
From: Karnik Ram <karnikram@gmail.com>
Date: Mon, 19 Oct 2020 10:40:18 +0530
Subject: [PATCH 12/42] Apply mask before feature extraction

---
 config/vins_rviz_config.rviz                 | 192 +++++++++---------
 feature_tracker/CMakeLists.txt               |   1 +
 feature_tracker/src/feature_tracker.cpp      |   9 +-
 feature_tracker/src/feature_tracker.h        |   4 +-
 feature_tracker/src/feature_tracker_node.cpp | 195 ++++++++++++++++++-
 feature_tracker/src/parameters.cpp           |   2 +
 feature_tracker/src/parameters.h             |   1 +
 7 files changed, 302 insertions(+), 102 deletions(-)

diff --git a/config/vins_rviz_config.rviz b/config/vins_rviz_config.rviz
index 6ed63a9..92ff49d 100644
--- a/config/vins_rviz_config.rviz
+++ b/config/vins_rviz_config.rviz
@@ -4,8 +4,8 @@ Panels:
     Name: Displays
     Property Tree Widget:
       Expanded: ~
-      Splitter Ratio: 0.465115994
-    Tree Height: 221
+      Splitter Ratio: 0.4651159942150116
+    Tree Height: 151
   - Class: rviz/Selection
     Name: Selection
   - Class: rviz/Tool Properties
@@ -14,7 +14,7 @@ Panels:
       - /2D Nav Goal1
       - /Publish Point1
     Name: Tool Properties
-    Splitter Ratio: 0.588679016
+    Splitter Ratio: 0.5886790156364441
   - Class: rviz/Views
     Expanded:
       - /Current View1
@@ -24,14 +24,18 @@ Panels:
     Experimental: false
     Name: Time
     SyncMode: 0
-    SyncSource: tracked image
+    SyncSource: ""
   - Class: rviz/Displays
     Help Height: 78
     Name: Displays
     Property Tree Widget:
       Expanded: ~
       Splitter Ratio: 0.5
-    Tree Height: 359
+    Tree Height: 363
+Preferences:
+  PromptSaveOnExit: true
+Toolbars:
+  toolButtonStyle: 2
 Visualization Manager:
   Class: ""
   Displays:
@@ -41,7 +45,7 @@ Visualization Manager:
       Color: 130; 130; 130
       Enabled: true
       Line Style:
-        Line Width: 0.0299999993
+        Line Width: 0.029999999329447746
         Value: Lines
       Name: Grid
       Normal Cell Count: 0
@@ -57,7 +61,7 @@ Visualization Manager:
       Enabled: true
       Length: 1
       Name: Axes
-      Radius: 0.100000001
+      Radius: 0.10000000149011612
       Reference Frame: <Fixed Frame>
       Value: true
     - Alpha: 1
@@ -65,9 +69,9 @@ Visualization Manager:
       Class: rviz/Path
       Color: 255; 0; 0
       Enabled: true
-      Head Diameter: 0.300000012
-      Head Length: 0.200000003
-      Length: 0.300000012
+      Head Diameter: 0.30000001192092896
+      Head Length: 0.20000000298023224
+      Length: 0.30000001192092896
       Line Style: Lines
       Line Width: 0.5
       Name: ground_truth_path
@@ -77,9 +81,9 @@ Visualization Manager:
         Z: 0
       Pose Color: 255; 85; 255
       Pose Style: None
-      Radius: 0.0299999993
-      Shaft Diameter: 0.100000001
-      Shaft Length: 0.100000001
+      Radius: 0.029999999329447746
+      Shaft Diameter: 0.10000000149011612
+      Shaft Length: 0.10000000149011612
       Topic: /benchmark_publisher/path
       Unreliable: false
       Value: true
@@ -114,11 +118,11 @@ Visualization Manager:
           Class: rviz/Path
           Color: 0; 255; 0
           Enabled: true
-          Head Diameter: 0.300000012
-          Head Length: 0.200000003
-          Length: 0.300000012
+          Head Diameter: 0.30000001192092896
+          Head Length: 0.20000000298023224
+          Length: 0.30000001192092896
           Line Style: Lines
-          Line Width: 0.0299999993
+          Line Width: 0.029999999329447746
           Name: Path
           Offset:
             X: 0
@@ -126,9 +130,9 @@ Visualization Manager:
             Z: 0
           Pose Color: 255; 85; 255
           Pose Style: None
-          Radius: 0.0299999993
-          Shaft Diameter: 0.100000001
-          Shaft Length: 0.100000001
+          Radius: 0.029999999329447746
+          Shaft Diameter: 0.10000000149011612
+          Shaft Length: 0.10000000149011612
           Topic: /vins_estimator/path
           Unreliable: false
           Value: true
@@ -163,7 +167,7 @@ Visualization Manager:
           Queue Size: 10
           Selectable: true
           Size (Pixels): 1
-          Size (m): 0.00999999978
+          Size (m): 0.009999999776482582
           Style: Points
           Topic: /vins_estimator/point_cloud
           Unreliable: false
@@ -214,7 +218,7 @@ Visualization Manager:
             {}
           Update Interval: 0
           Value: true
-      Enabled: false
+      Enabled: true
       Name: VIO
     - Class: rviz/Group
       Displays:
@@ -223,11 +227,11 @@ Visualization Manager:
           Class: rviz/Path
           Color: 0; 255; 0
           Enabled: true
-          Head Diameter: 0.300000012
-          Head Length: 0.200000003
-          Length: 0.300000012
+          Head Diameter: 0.30000001192092896
+          Head Length: 0.20000000298023224
+          Length: 0.30000001192092896
           Line Style: Lines
-          Line Width: 0.0299999993
+          Line Width: 0.029999999329447746
           Name: pose_graph_path
           Offset:
             X: 0
@@ -235,9 +239,9 @@ Visualization Manager:
             Z: 0
           Pose Color: 255; 85; 255
           Pose Style: None
-          Radius: 0.0299999993
-          Shaft Diameter: 0.100000001
-          Shaft Length: 0.100000001
+          Radius: 0.029999999329447746
+          Shaft Diameter: 0.10000000149011612
+          Shaft Length: 0.10000000149011612
           Topic: /pose_graph/pose_graph_path
           Unreliable: false
           Value: true
@@ -246,11 +250,11 @@ Visualization Manager:
           Class: rviz/Path
           Color: 255; 170; 0
           Enabled: true
-          Head Diameter: 0.300000012
-          Head Length: 0.200000003
-          Length: 0.300000012
+          Head Diameter: 0.30000001192092896
+          Head Length: 0.20000000298023224
+          Length: 0.30000001192092896
           Line Style: Lines
-          Line Width: 0.0299999993
+          Line Width: 0.029999999329447746
           Name: base_path
           Offset:
             X: 0
@@ -258,9 +262,9 @@ Visualization Manager:
             Z: 0
           Pose Color: 255; 85; 255
           Pose Style: None
-          Radius: 0.0299999993
-          Shaft Diameter: 0.100000001
-          Shaft Length: 0.100000001
+          Radius: 0.029999999329447746
+          Shaft Diameter: 0.10000000149011612
+          Shaft Length: 0.10000000149011612
           Topic: /pose_graph/base_path
           Unreliable: false
           Value: true
@@ -305,11 +309,11 @@ Visualization Manager:
           Class: rviz/Path
           Color: 25; 255; 0
           Enabled: true
-          Head Diameter: 0.300000012
-          Head Length: 0.200000003
-          Length: 0.300000012
+          Head Diameter: 0.30000001192092896
+          Head Length: 0.20000000298023224
+          Length: 0.30000001192092896
           Line Style: Lines
-          Line Width: 0.300000012
+          Line Width: 0.30000001192092896
           Name: Sequence1
           Offset:
             X: 0
@@ -317,9 +321,9 @@ Visualization Manager:
             Z: 0
           Pose Color: 255; 85; 255
           Pose Style: None
-          Radius: 0.0299999993
-          Shaft Diameter: 0.100000001
-          Shaft Length: 0.100000001
+          Radius: 0.029999999329447746
+          Shaft Diameter: 0.10000000149011612
+          Shaft Length: 0.10000000149011612
           Topic: /pose_graph/path_1
           Unreliable: false
           Value: true
@@ -328,11 +332,11 @@ Visualization Manager:
           Class: rviz/Path
           Color: 255; 0; 0
           Enabled: true
-          Head Diameter: 0.300000012
-          Head Length: 0.200000003
-          Length: 0.300000012
+          Head Diameter: 0.30000001192092896
+          Head Length: 0.20000000298023224
+          Length: 0.30000001192092896
           Line Style: Lines
-          Line Width: 0.300000012
+          Line Width: 0.30000001192092896
           Name: Sequence2
           Offset:
             X: 0
@@ -340,9 +344,9 @@ Visualization Manager:
             Z: 0
           Pose Color: 255; 85; 255
           Pose Style: None
-          Radius: 0.0299999993
-          Shaft Diameter: 0.100000001
-          Shaft Length: 0.100000001
+          Radius: 0.029999999329447746
+          Shaft Diameter: 0.10000000149011612
+          Shaft Length: 0.10000000149011612
           Topic: /pose_graph/path_2
           Unreliable: false
           Value: true
@@ -351,11 +355,11 @@ Visualization Manager:
           Class: rviz/Path
           Color: 0; 85; 255
           Enabled: true
-          Head Diameter: 0.300000012
-          Head Length: 0.200000003
-          Length: 0.300000012
+          Head Diameter: 0.30000001192092896
+          Head Length: 0.20000000298023224
+          Length: 0.30000001192092896
           Line Style: Lines
-          Line Width: 0.300000012
+          Line Width: 0.30000001192092896
           Name: Sequence3
           Offset:
             X: 0
@@ -363,9 +367,9 @@ Visualization Manager:
             Z: 0
           Pose Color: 255; 85; 255
           Pose Style: None
-          Radius: 0.0299999993
-          Shaft Diameter: 0.100000001
-          Shaft Length: 0.100000001
+          Radius: 0.029999999329447746
+          Shaft Diameter: 0.10000000149011612
+          Shaft Length: 0.10000000149011612
           Topic: /pose_graph/path_3
           Unreliable: false
           Value: true
@@ -374,11 +378,11 @@ Visualization Manager:
           Class: rviz/Path
           Color: 255; 170; 0
           Enabled: true
-          Head Diameter: 0.300000012
-          Head Length: 0.200000003
-          Length: 0.300000012
+          Head Diameter: 0.30000001192092896
+          Head Length: 0.20000000298023224
+          Length: 0.30000001192092896
           Line Style: Lines
-          Line Width: 0.300000012
+          Line Width: 0.30000001192092896
           Name: Sequence4
           Offset:
             X: 0
@@ -386,9 +390,9 @@ Visualization Manager:
             Z: 0
           Pose Color: 255; 85; 255
           Pose Style: None
-          Radius: 0.0299999993
-          Shaft Diameter: 0.100000001
-          Shaft Length: 0.100000001
+          Radius: 0.029999999329447746
+          Shaft Diameter: 0.10000000149011612
+          Shaft Length: 0.10000000149011612
           Topic: /pose_graph/path_4
           Unreliable: false
           Value: true
@@ -397,11 +401,11 @@ Visualization Manager:
           Class: rviz/Path
           Color: 255; 170; 255
           Enabled: true
-          Head Diameter: 0.300000012
-          Head Length: 0.200000003
-          Length: 0.300000012
+          Head Diameter: 0.30000001192092896
+          Head Length: 0.20000000298023224
+          Length: 0.30000001192092896
           Line Style: Lines
-          Line Width: 0.0299999993
+          Line Width: 0.029999999329447746
           Name: Sequence5
           Offset:
             X: 0
@@ -409,9 +413,9 @@ Visualization Manager:
             Z: 0
           Pose Color: 255; 85; 255
           Pose Style: None
-          Radius: 0.0299999993
-          Shaft Diameter: 0.100000001
-          Shaft Length: 0.100000001
+          Radius: 0.029999999329447746
+          Shaft Diameter: 0.10000000149011612
+          Shaft Length: 0.10000000149011612
           Topic: /pose_graph/path_5
           Unreliable: false
           Value: true
@@ -420,11 +424,11 @@ Visualization Manager:
           Class: rviz/Path
           Color: 25; 255; 0
           Enabled: true
-          Head Diameter: 0.300000012
-          Head Length: 0.200000003
-          Length: 0.300000012
+          Head Diameter: 0.30000001192092896
+          Head Length: 0.20000000298023224
+          Length: 0.30000001192092896
           Line Style: Lines
-          Line Width: 0.0299999993
+          Line Width: 0.029999999329447746
           Name: no_loop_path
           Offset:
             X: 0
@@ -432,9 +436,9 @@ Visualization Manager:
             Z: 0
           Pose Color: 255; 85; 255
           Pose Style: None
-          Radius: 0.0299999993
-          Shaft Diameter: 0.100000001
-          Shaft Length: 0.100000001
+          Radius: 0.029999999329447746
+          Shaft Diameter: 0.10000000149011612
+          Shaft Length: 0.10000000149011612
           Topic: /pose_graph/no_loop_path
           Unreliable: false
           Value: true
@@ -443,6 +447,7 @@ Visualization Manager:
   Enabled: true
   Global Options:
     Background Color: 0; 0; 0
+    Default Light: true
     Fixed Frame: world
     Frame Rate: 30
   Name: root
@@ -452,7 +457,10 @@ Visualization Manager:
     - Class: rviz/FocusCamera
     - Class: rviz/Measure
     - Class: rviz/SetInitialPose
+      Theta std deviation: 0.2617993950843811
       Topic: /initialpose
+      X std deviation: 0.5
+      Y std deviation: 0.5
     - Class: rviz/SetGoal
       Topic: /move_base_simple/goal
     - Class: rviz/PublishPoint
@@ -462,33 +470,33 @@ Visualization Manager:
   Views:
     Current:
       Class: rviz/XYOrbit
-      Distance: 20.9684067
+      Distance: 20.968406677246094
       Enable Stereo Rendering:
-        Stereo Eye Separation: 0.0599999987
+        Stereo Eye Separation: 0.05999999865889549
         Stereo Focal Distance: 1
         Swap Stereo Eyes: false
         Value: false
       Focal Point:
-        X: -2.7069304
-        Y: -1.26974416
-        Z: 2.1410624e-05
+        X: -2.70693039894104
+        Y: -1.2697441577911377
+        Z: 2.141062395821791e-5
       Focal Shape Fixed Size: true
-      Focal Shape Size: 0.0500000007
+      Focal Shape Size: 0.05000000074505806
       Invert Z Axis: false
       Name: Current View
-      Near Clip Distance: 0.00999999978
-      Pitch: 1.0797962
+      Near Clip Distance: 0.009999999776482582
+      Pitch: 1.0797961950302124
       Target Frame: <Fixed Frame>
       Value: XYOrbit (rviz)
-      Yaw: 3.08722663
+      Yaw: 3.087226629257202
     Saved: ~
 Window Geometry:
   Displays:
     collapsed: false
-  Height: 912
+  Height: 734
   Hide Left Dock: false
   Hide Right Dock: true
-  QMainWindow State: 000000ff00000000fd0000000400000000000001df00000309fc0200000010fb0000000a0049006d00610067006501000000280000013d0000000000000000fb0000001200530065006c0065006300740069006f006e00000001e10000009b0000006400fffffffb0000001e0054006f006f006c002000500072006f007000650072007400690065007302000001ed000001df00000185000000a3fb000000120056006900650077007300200054006f006f02000001df000002110000018500000122fb000000200054006f006f006c002000500072006f0070006500720074006900650073003203000002880000011d000002210000017afb0000002000730065006c0065006300740069006f006e00200062007500660066006500720200000138000000aa0000023a00000294fb00000014005700690064006500530074006500720065006f02000000e6000000d2000003ee0000030bfb0000000c004b0069006e0065006300740200000186000001060000030c00000261fb0000001200720061007700200049006d0061006700650000000028000000300000000000000000fb00000012007200610077005f0069006d0061006700650000000028000000f90000001600fffffffb0000001a0074007200610063006b0065006400200069006d00610067006501000000280000012c0000001600fffffffb00000020006c006f006f0070005f006d0061007400630068005f0069006d006100670065010000015a000000b30000001600fffffffb000000100044006900730070006c00610079007301000002130000011e000000dd00fffffffc000000280000011e0000000000fffffffa000000000100000002fb0000001200720061007700200049006d0061006700650000000000ffffffff0000000000000000fb0000001a0074007200610063006b0065006400200069006d0061006700650100000000000002370000000000000000fb0000001000410052005f0069006d0061006700650100000373000000160000000000000000fb0000001200720061007700200069006d006100670065010000038f000000160000000000000000000000010000020800000399fc0200000003fb0000001e0054006f006f006c002000500072006f00700065007200740069006500730100000041000000780000000000000000fc00000028000003990000000000fffffffaffffffff0100000002fb000000100044006900730070006c0061007900730000000000ffffffff0000016a00fffffffb0000000a00560069006500770073000000023f0000016a0000010f00fffffffb0000001200530065006c0065006300740069006f006e010000025a000000b200000000000000000000000200000490000000a9fc0100000001fb0000000a00560069006500770073030000004e00000080000002e100000197000000030000056e0000003bfc0100000002fb0000000800540069006d006501000000000000056e0000030000fffffffb0000000800540069006d00650100000000000004500000000000000000000003890000030900000004000000040000000800000008fc0000000100000002000000010000000a0054006f006f006c00730100000000ffffffff0000000000000000
+  QMainWindow State: 000000ff00000000fd00000004000000000000015600000243fc0200000010fb0000000a0049006d00610067006501000000280000013d0000000000000000fb0000001200530065006c0065006300740069006f006e00000001e10000009b0000005c00fffffffb0000001e0054006f006f006c002000500072006f007000650072007400690065007302000001ed000001df00000185000000a3fb000000120056006900650077007300200054006f006f02000001df000002110000018500000122fb000000200054006f006f006c002000500072006f0070006500720074006900650073003203000002880000011d000002210000017afb0000002000730065006c0065006300740069006f006e00200062007500660066006500720200000138000000aa0000023a00000294fb00000014005700690064006500530074006500720065006f02000000e6000000d2000003ee0000030bfb0000000c004b0069006e0065006300740200000186000001060000030c00000261fb0000001200720061007700200049006d0061006700650000000028000000300000000000000000fb00000012007200610077005f0069006d0061006700650000000028000000f90000001600fffffffb0000001a0074007200610063006b0065006400200069006d006100670065010000003d000000de0000001600fffffffb00000020006c006f006f0070005f006d0061007400630068005f0069006d0061006700650100000121000000850000001600fffffffb000000100044006900730070006c00610079007301000001ac000000d4000000c900fffffffc000000280000011e0000000000fffffffa000000000100000002fb0000001200720061007700200049006d0061006700650000000000ffffffff0000000000000000fb0000001a0074007200610063006b0065006400200069006d0061006700650100000000000002370000000000000000fb0000001000410052005f0069006d0061006700650100000373000000160000000000000000fb0000001200720061007700200069006d006100670065010000038f000000160000000000000000000000010000020800000399fc0200000003fb0000001e0054006f006f006c002000500072006f00700065007200740069006500730100000041000000780000000000000000fc00000028000003990000000000fffffffaffffffff0100000002fb000000100044006900730070006c0061007900730000000000ffffffff0000015600fffffffb0000000a00560069006500770073000000023f0000016a0000010000fffffffb0000001200530065006c0065006300740069006f006e010000025a000000b200000000000000000000000200000490000000a9fc0100000001fb0000000a00560069006500770073030000004e00000080000002e10000019700000003000002a30000003bfc0100000002fb0000000800540069006d00650100000000000002a3000002eb00fffffffb0000000800540069006d00650100000000000004500000000000000000000001470000024300000004000000040000000800000008fc0000000100000002000000010000000a0054006f006f006c00730100000000ffffffff0000000000000000
   Selection:
     collapsed: false
   Time:
@@ -497,9 +505,9 @@ Window Geometry:
     collapsed: false
   Views:
     collapsed: true
-  Width: 1390
-  X: 2127
-  Y: 109
+  Width: 675
+  X: 685
+  Y: 4
   loop_match_image:
     collapsed: false
   raw_image:
diff --git a/feature_tracker/CMakeLists.txt b/feature_tracker/CMakeLists.txt
index bc3fb44..439f706 100644
--- a/feature_tracker/CMakeLists.txt
+++ b/feature_tracker/CMakeLists.txt
@@ -11,6 +11,7 @@ find_package(catkin REQUIRED COMPONENTS
     sensor_msgs
     cv_bridge
     camera_model
+    message_filters
     )
 
 find_package(OpenCV REQUIRED)
diff --git a/feature_tracker/src/feature_tracker.cpp b/feature_tracker/src/feature_tracker.cpp
index 41322b8..9d5de16 100644
--- a/feature_tracker/src/feature_tracker.cpp
+++ b/feature_tracker/src/feature_tracker.cpp
@@ -33,12 +33,13 @@ FeatureTracker::FeatureTracker()
 {
 }
 
-void FeatureTracker::setMask()
+void FeatureTracker::setMask(const cv::Mat &_mask)
 {
     if(FISHEYE)
         mask = fisheye_mask.clone();
     else
-        mask = cv::Mat(ROW, COL, CV_8UC1, cv::Scalar(255));
+        //mask = cv::Mat(ROW, COL, CV_8UC1, cv::Scalar(255));
+        mask = _mask.clone();
     
 
     // prefer to keep features that are tracked for long time
@@ -78,7 +79,7 @@ void FeatureTracker::addPoints()
     }
 }
 
-void FeatureTracker::readImage(const cv::Mat &_img, double _cur_time)
+void FeatureTracker::readImage(const cv::Mat &_img, const cv::Mat &_mask, double _cur_time)
 {
     cv::Mat img;
     TicToc t_r;
@@ -132,7 +133,7 @@ void FeatureTracker::readImage(const cv::Mat &_img, double _cur_time)
         rejectWithF();
         ROS_DEBUG("set mask begins");
         TicToc t_m;
-        setMask();
+        setMask(_mask);
         ROS_DEBUG("set mask costs %fms", t_m.toc());
 
         ROS_DEBUG("detect feature begins");
diff --git a/feature_tracker/src/feature_tracker.h b/feature_tracker/src/feature_tracker.h
index 9862ec1..cb376db 100644
--- a/feature_tracker/src/feature_tracker.h
+++ b/feature_tracker/src/feature_tracker.h
@@ -30,9 +30,9 @@ class FeatureTracker
   public:
     FeatureTracker();
 
-    void readImage(const cv::Mat &_img,double _cur_time);
+    void readImage(const cv::Mat &_img, const cv::Mat &_mask, double _cur_time);
 
-    void setMask();
+    void setMask(const cv::Mat &_mask);
 
     void addPoints();
 
diff --git a/feature_tracker/src/feature_tracker_node.cpp b/feature_tracker/src/feature_tracker_node.cpp
index 5a5261c..a0dbd25 100644
--- a/feature_tracker/src/feature_tracker_node.cpp
+++ b/feature_tracker/src/feature_tracker_node.cpp
@@ -6,6 +6,7 @@
 #include <std_msgs/Bool.h>
 #include <cv_bridge/cv_bridge.h>
 #include <message_filters/subscriber.h>
+#include <message_filters/time_synchronizer.h>
 
 #include "feature_tracker.h"
 
@@ -25,7 +26,7 @@ bool first_image_flag = true;
 double last_image_time = 0;
 bool init_pub = 0;
 
-void img_callback(const sensor_msgs::ImageConstPtr &img_msg)
+void callback(const sensor_msgs::ImageConstPtr &img_msg, const sensor_msgs::ImageConstPtr &mask_msg)
 {
     if(first_image_flag)
     {
@@ -61,7 +62,7 @@ void img_callback(const sensor_msgs::ImageConstPtr &img_msg)
     else
         PUB_THIS_FRAME = false;
 
-    cv_bridge::CvImageConstPtr ptr;
+    cv_bridge::CvImageConstPtr ptr, mask_ptr;
     if (img_msg->encoding == "8UC1")
     {
         sensor_msgs::Image img;
@@ -77,13 +78,15 @@ void img_callback(const sensor_msgs::ImageConstPtr &img_msg)
     else
         ptr = cv_bridge::toCvCopy(img_msg, sensor_msgs::image_encodings::MONO8);
 
+    mask_ptr = cv_bridge::toCvCopy(mask_msg, sensor_msgs::image_encodings::MONO8);
     cv::Mat show_img = ptr->image;
+
     TicToc t_r;
     for (int i = 0; i < NUM_OF_CAM; i++)
     {
         ROS_DEBUG("processing camera %d", i);
         if (i != 1 || !STEREO_TRACK)
-            trackerData[i].readImage(ptr->image.rowRange(ROW * i, ROW * (i + 1)), img_msg->header.stamp.toSec());
+            trackerData[i].readImage(ptr->image.rowRange(ROW * i, ROW * (i + 1)), mask_ptr->image, img_msg->header.stamp.toSec());
         else
         {
             if (EQUALIZE)
@@ -201,8 +204,187 @@ void img_callback(const sensor_msgs::ImageConstPtr &img_msg)
         }
     }
     ROS_INFO("whole feature tracker processing costs: %f", t_r.toc());
+
 }
 
+//void img_callback(const sensor_msgs::ImageConstPtr &img_msg)
+//{
+//    if(first_image_flag)
+//    {
+//        first_image_flag = false;
+//        first_image_time = img_msg->header.stamp.toSec();
+//        last_image_time = img_msg->header.stamp.toSec();
+//        return;
+//    }
+//    // detect unstable camera stream
+//    if (img_msg->header.stamp.toSec() - last_image_time > 1.0 || img_msg->header.stamp.toSec() < last_image_time)
+//    {
+//        ROS_WARN("image discontinue! reset the feature tracker!");
+//        first_image_flag = true; 
+//        last_image_time = 0;
+//        pub_count = 1;
+//        std_msgs::Bool restart_flag;
+//        restart_flag.data = true;
+//        pub_restart.publish(restart_flag);
+//        return;
+//    }
+//    last_image_time = img_msg->header.stamp.toSec();
+//    // frequency control
+//    if (round(1.0 * pub_count / (img_msg->header.stamp.toSec() - first_image_time)) <= FREQ)
+//    {
+//        PUB_THIS_FRAME = true;
+//        // reset the frequency control
+//        if (abs(1.0 * pub_count / (img_msg->header.stamp.toSec() - first_image_time) - FREQ) < 0.01 * FREQ)
+//        {
+//            first_image_time = img_msg->header.stamp.toSec();
+//            pub_count = 0;
+//        }
+//    }
+//    else
+//        PUB_THIS_FRAME = false;
+//
+//    cv_bridge::CvImageConstPtr ptr;
+//    if (img_msg->encoding == "8UC1")
+//    {
+//        sensor_msgs::Image img;
+//        img.header = img_msg->header;
+//        img.height = img_msg->height;
+//        img.width = img_msg->width;
+//        img.is_bigendian = img_msg->is_bigendian;
+//        img.step = img_msg->step;
+//        img.data = img_msg->data;
+//        img.encoding = "mono8";
+//        ptr = cv_bridge::toCvCopy(img, sensor_msgs::image_encodings::MONO8);
+//    }
+//    else
+//        ptr = cv_bridge::toCvCopy(img_msg, sensor_msgs::image_encodings::MONO8);
+//
+//    cv::Mat show_img = ptr->image;
+//    TicToc t_r;
+//    for (int i = 0; i < NUM_OF_CAM; i++)
+//    {
+//        ROS_DEBUG("processing camera %d", i);
+//        if (i != 1 || !STEREO_TRACK)
+//            trackerData[i].readImage(ptr->image.rowRange(ROW * i, ROW * (i + 1)), img_msg->header.stamp.toSec());
+//        else
+//        {
+//            if (EQUALIZE)
+//            {
+//                cv::Ptr<cv::CLAHE> clahe = cv::createCLAHE();
+//                clahe->apply(ptr->image.rowRange(ROW * i, ROW * (i + 1)), trackerData[i].cur_img);
+//            }
+//            else
+//                trackerData[i].cur_img = ptr->image.rowRange(ROW * i, ROW * (i + 1));
+//        }
+//
+//#if SHOW_UNDISTORTION
+//        trackerData[i].showUndistortion("undistrotion_" + std::to_string(i));
+//#endif
+//    }
+//
+//    for (unsigned int i = 0;; i++)
+//    {
+//        bool completed = false;
+//        for (int j = 0; j < NUM_OF_CAM; j++)
+//            if (j != 1 || !STEREO_TRACK)
+//                completed |= trackerData[j].updateID(i);
+//        if (!completed)
+//            break;
+//    }
+//
+//   if (PUB_THIS_FRAME)
+//   {
+//        pub_count++;
+//        sensor_msgs::PointCloudPtr feature_points(new sensor_msgs::PointCloud);
+//        sensor_msgs::ChannelFloat32 id_of_point;
+//        sensor_msgs::ChannelFloat32 u_of_point;
+//        sensor_msgs::ChannelFloat32 v_of_point;
+//        sensor_msgs::ChannelFloat32 velocity_x_of_point;
+//        sensor_msgs::ChannelFloat32 velocity_y_of_point;
+//
+//        feature_points->header = img_msg->header;
+//        feature_points->header.frame_id = "world";
+//
+//        vector<set<int>> hash_ids(NUM_OF_CAM);
+//        for (int i = 0; i < NUM_OF_CAM; i++)
+//        {
+//            auto &un_pts = trackerData[i].cur_un_pts;
+//            auto &cur_pts = trackerData[i].cur_pts;
+//            auto &ids = trackerData[i].ids;
+//            auto &pts_velocity = trackerData[i].pts_velocity;
+//            for (unsigned int j = 0; j < ids.size(); j++)
+//            {
+//                if (trackerData[i].track_cnt[j] > 1)
+//                {
+//                    int p_id = ids[j];
+//                    hash_ids[i].insert(p_id);
+//                    geometry_msgs::Point32 p;
+//                    p.x = un_pts[j].x;
+//                    p.y = un_pts[j].y;
+//                    p.z = 1;
+//
+//                    feature_points->points.push_back(p);
+//                    id_of_point.values.push_back(p_id * NUM_OF_CAM + i);
+//                    u_of_point.values.push_back(cur_pts[j].x);
+//                    v_of_point.values.push_back(cur_pts[j].y);
+//                    velocity_x_of_point.values.push_back(pts_velocity[j].x);
+//                    velocity_y_of_point.values.push_back(pts_velocity[j].y);
+//                }
+//            }
+//        }
+//        feature_points->channels.push_back(id_of_point);
+//        feature_points->channels.push_back(u_of_point);
+//        feature_points->channels.push_back(v_of_point);
+//        feature_points->channels.push_back(velocity_x_of_point);
+//        feature_points->channels.push_back(velocity_y_of_point);
+//        ROS_DEBUG("publish %f, at %f", feature_points->header.stamp.toSec(), ros::Time::now().toSec());
+//        // skip the first image; since no optical speed on frist image
+//        if (!init_pub)
+//        {
+//            init_pub = 1;
+//        }
+//        else
+//            pub_img.publish(feature_points);
+//
+//        if (SHOW_TRACK)
+//        {
+//            ptr = cv_bridge::cvtColor(ptr, sensor_msgs::image_encodings::BGR8);
+//            //cv::Mat stereo_img(ROW * NUM_OF_CAM, COL, CV_8UC3);
+//            cv::Mat stereo_img = ptr->image;
+//
+//            for (int i = 0; i < NUM_OF_CAM; i++)
+//            {
+//                cv::Mat tmp_img = stereo_img.rowRange(i * ROW, (i + 1) * ROW);
+//                cv::cvtColor(show_img, tmp_img, CV_GRAY2RGB);
+//
+//                for (unsigned int j = 0; j < trackerData[i].cur_pts.size(); j++)
+//                {
+//                    double len = std::min(1.0, 1.0 * trackerData[i].track_cnt[j] / WINDOW_SIZE);
+//                    cv::circle(tmp_img, trackerData[i].cur_pts[j], 2, cv::Scalar(255 * (1 - len), 0, 255 * len), 2);
+//                    //draw speed line
+//                    /*
+//                    Vector2d tmp_cur_un_pts (trackerData[i].cur_un_pts[j].x, trackerData[i].cur_un_pts[j].y);
+//                    Vector2d tmp_pts_velocity (trackerData[i].pts_velocity[j].x, trackerData[i].pts_velocity[j].y);
+//                    Vector3d tmp_prev_un_pts;
+//                    tmp_prev_un_pts.head(2) = tmp_cur_un_pts - 0.10 * tmp_pts_velocity;
+//                    tmp_prev_un_pts.z() = 1;
+//                    Vector2d tmp_prev_uv;
+//                    trackerData[i].m_camera->spaceToPlane(tmp_prev_un_pts, tmp_prev_uv);
+//                    cv::line(tmp_img, trackerData[i].cur_pts[j], cv::Point2f(tmp_prev_uv.x(), tmp_prev_uv.y()), cv::Scalar(255 , 0, 0), 1 , 8, 0);
+//                    */
+//                    //char name[10];
+//                    //sprintf(name, "%d", trackerData[i].ids[j]);
+//                    //cv::putText(tmp_img, name, trackerData[i].cur_pts[j], cv::FONT_HERSHEY_SIMPLEX, 0.5, cv::Scalar(0, 0, 0));
+//                }
+//            }
+//            //cv::imshow("vis", stereo_img);
+//            //cv::waitKey(5);
+//            pub_match.publish(ptr->toImageMsg());
+//        }
+//    }
+//    ROS_INFO("whole feature tracker processing costs: %f", t_r.toc());
+//}
+//
 int main(int argc, char **argv)
 {
     ros::init(argc, argv, "feature_tracker");
@@ -228,7 +410,12 @@ int main(int argc, char **argv)
         }
     }
 
-    ros::Subscriber sub_img = n.subscribe(IMAGE_TOPIC, 100, img_callback);
+    //ros::Subscriber sub_img = n.subscribe(IMAGE_TOPIC, 100, img_callback);
+    message_filters::Subscriber<sensor_msgs::Image> image_sub(n, IMAGE_TOPIC, 100);
+    message_filters::Subscriber<sensor_msgs::Image> mask_image_sub(n, MASK_TOPIC, 100);
+
+    message_filters::TimeSynchronizer<sensor_msgs::Image, sensor_msgs::Image> sync(image_sub, mask_image_sub, 10);
+    sync.registerCallback(boost::bind(&callback, _1, _2));
 
     pub_img = n.advertise<sensor_msgs::PointCloud>("feature", 1000);
     pub_match = n.advertise<sensor_msgs::Image>("feature_img",1000);
diff --git a/feature_tracker/src/parameters.cpp b/feature_tracker/src/parameters.cpp
index 23c35c8..417efb2 100644
--- a/feature_tracker/src/parameters.cpp
+++ b/feature_tracker/src/parameters.cpp
@@ -1,6 +1,7 @@
 #include "parameters.h"
 
 std::string IMAGE_TOPIC;
+std::string MASK_TOPIC;
 std::string IMU_TOPIC;
 std::vector<std::string> CAM_NAMES;
 std::string FISHEYE_MASK;
@@ -46,6 +47,7 @@ void readParameters(ros::NodeHandle &n)
     std::string VINS_FOLDER_PATH = readParam<std::string>(n, "vins_folder");
 
     fsSettings["image_topic"] >> IMAGE_TOPIC;
+    fsSettings["mask_topic"] >> MASK_TOPIC;
     fsSettings["imu_topic"] >> IMU_TOPIC;
     MAX_CNT = fsSettings["max_cnt"];
     MIN_DIST = fsSettings["min_dist"];
diff --git a/feature_tracker/src/parameters.h b/feature_tracker/src/parameters.h
index 1bb578b..44e5f9c 100644
--- a/feature_tracker/src/parameters.h
+++ b/feature_tracker/src/parameters.h
@@ -9,6 +9,7 @@ const int NUM_OF_CAM = 1;
 
 
 extern std::string IMAGE_TOPIC;
+extern std::string MASK_TOPIC;
 extern std::string IMU_TOPIC;
 extern std::string FISHEYE_MASK;
 extern std::vector<std::string> CAM_NAMES;
-- 
2.17.1


From 8948e61ce641d532d902f6adacd97a890c7456dd Mon Sep 17 00:00:00 2001
From: Karnik Ram <karnikram@gmail.com>
Date: Mon, 19 Oct 2020 11:11:28 +0530
Subject: [PATCH 13/42] Apply mask after extraction and with erosion

---
 feature_tracker/src/feature_tracker.cpp | 22 +++++++++++++---------
 feature_tracker/src/feature_tracker.h   |  4 ++--
 2 files changed, 15 insertions(+), 11 deletions(-)

diff --git a/feature_tracker/src/feature_tracker.cpp b/feature_tracker/src/feature_tracker.cpp
index 9d5de16..4384928 100644
--- a/feature_tracker/src/feature_tracker.cpp
+++ b/feature_tracker/src/feature_tracker.cpp
@@ -33,13 +33,12 @@ FeatureTracker::FeatureTracker()
 {
 }
 
-void FeatureTracker::setMask(const cv::Mat &_mask)
+void FeatureTracker::setMask()
 {
     if(FISHEYE)
         mask = fisheye_mask.clone();
     else
-        //mask = cv::Mat(ROW, COL, CV_8UC1, cv::Scalar(255));
-        mask = _mask.clone();
+        mask = cv::Mat(ROW, COL, CV_8UC1, cv::Scalar(255));
     
 
     // prefer to keep features that are tracked for long time
@@ -69,13 +68,18 @@ void FeatureTracker::setMask(const cv::Mat &_mask)
     }
 }
 
-void FeatureTracker::addPoints()
+void FeatureTracker::addPoints(const cv::Mat &_mask)
 {
+    cv::Mat dynamic_mask;
+    cv::erode(_mask, dynamic_mask, cv::Mat(), cv::Point(-1, -1), 2, 1, 1);
     for (auto &p : n_pts)
     {
-        forw_pts.push_back(p);
-        ids.push_back(-1);
-        track_cnt.push_back(1);
+        if(dynamic_mask.at<uchar>(p) == 255)
+        {
+            forw_pts.push_back(p);
+            ids.push_back(-1);
+            track_cnt.push_back(1);
+        }
     }
 }
 
@@ -133,7 +137,7 @@ void FeatureTracker::readImage(const cv::Mat &_img, const cv::Mat &_mask, double
         rejectWithF();
         ROS_DEBUG("set mask begins");
         TicToc t_m;
-        setMask(_mask);
+        setMask();
         ROS_DEBUG("set mask costs %fms", t_m.toc());
 
         ROS_DEBUG("detect feature begins");
@@ -155,7 +159,7 @@ void FeatureTracker::readImage(const cv::Mat &_img, const cv::Mat &_mask, double
 
         ROS_DEBUG("add feature begins");
         TicToc t_a;
-        addPoints();
+        addPoints(_mask);
         ROS_DEBUG("selectFeature costs: %fms", t_a.toc());
     }
     prev_img = cur_img;
diff --git a/feature_tracker/src/feature_tracker.h b/feature_tracker/src/feature_tracker.h
index cb376db..c98c7ac 100644
--- a/feature_tracker/src/feature_tracker.h
+++ b/feature_tracker/src/feature_tracker.h
@@ -32,9 +32,9 @@ class FeatureTracker
 
     void readImage(const cv::Mat &_img, const cv::Mat &_mask, double _cur_time);
 
-    void setMask(const cv::Mat &_mask);
+    void setMask();
 
-    void addPoints();
+    void addPoints(const cv::Mat &_mask);
 
     bool updateID(unsigned int i);
 
-- 
2.17.1


From cac43fd693103c98cbf95fa628b5f953681b3384 Mon Sep 17 00:00:00 2001
From: Karnik Ram <karnikram@gmail.com>
Date: Sun, 29 Nov 2020 11:29:04 +0530
Subject: [PATCH 14/42] Changes for debugging

---
 vins_estimator/src/estimator.cpp          | 17 ++++++++++-------
 vins_estimator/src/initial/solve_5pts.cpp |  7 ++++---
 2 files changed, 14 insertions(+), 10 deletions(-)

diff --git a/vins_estimator/src/estimator.cpp b/vins_estimator/src/estimator.cpp
index 096ef10..5b302ea 100644
--- a/vins_estimator/src/estimator.cpp
+++ b/vins_estimator/src/estimator.cpp
@@ -275,9 +275,12 @@ bool Estimator::initialStructure()
         return false;
     }
     GlobalSFM sfm;
-    if(!sfm.constructH(frame_count + 1, Q, T, l,
-              relative_R, relative_T, n,
-              sfm_f, sfm_tracked_points))
+    //if(!sfm.constructH(frame_count + 1, Q, T, l,
+    //          relative_R, relative_T, n,
+    //          sfm_f, sfm_tracked_points))
+    if(!sfm.construct(frame_count + 1, Q, T, l,
+                relative_R, relative_T,
+                sfm_f, sfm_tracked_points))
     {
         ROS_DEBUG("global SFM failed!");
         marginalization_flag = MARGIN_OLD;
@@ -808,8 +811,8 @@ void Estimator::optimization()
                 ProjectionFactor *f = new ProjectionFactor(pts_i, pts_j);
                 problem.AddResidualBlock(f, loss_function, para_Pose[imu_i], para_Pose[imu_j], para_Ex_Pose[0], para_Feature[feature_index]);
 
-                ceres::CostFunction *h_cost_function = HomographyFactor::Create(pts_i, pts_j);
-                problem.AddResidualBlock(h_cost_function, loss_function, para_Pose[imu_i], para_Pose[imu_j], para_N, para_Ex_Pose[0]);
+                //ceres::CostFunction *h_cost_function = HomographyFactor::Create(pts_i, pts_j);
+                //problem.AddResidualBlock(h_cost_function, loss_function, para_Pose[imu_i], para_Pose[imu_j], para_N, para_Ex_Pose[0]);
             }
             f_m_cnt++;
         }
@@ -846,7 +849,7 @@ void Estimator::optimization()
                     ProjectionFactor *f = new ProjectionFactor(pts_i, pts_j);
                     problem.AddResidualBlock(f, loss_function, para_Pose[start], relo_Pose, para_Ex_Pose[0], para_Feature[feature_index]);
                     retrive_feature_index++;
-                }     
+                }
             }
         }
 
@@ -882,7 +885,7 @@ void Estimator::optimization()
 
         if (last_marginalization_info)
         {
-            vector<int> drop_set;
+            vector<int> drop_set; 
             for (int i = 0; i < static_cast<int>(last_marginalization_parameter_blocks.size()); i++)
             {
                 if (last_marginalization_parameter_blocks[i] == para_Pose[0] ||
diff --git a/vins_estimator/src/initial/solve_5pts.cpp b/vins_estimator/src/initial/solve_5pts.cpp
index bdc87a3..57485af 100644
--- a/vins_estimator/src/initial/solve_5pts.cpp
+++ b/vins_estimator/src/initial/solve_5pts.cpp
@@ -275,7 +275,7 @@ void MotionEstimator::decomposeH(const cv::Mat &H, const cv::Mat &K, const Matri
 
             Vector3d t;
             cv::cv2eigen(cv_ts[i], t);
-            Tr.block(0,3,3,1) = t;
+            Tr.block(0,3,3,1) = t.normalized();
 
             //Tr = TrIC * Tr * TrIC.inverse();
             Tr = Tr.inverse().eval();
@@ -283,6 +283,7 @@ void MotionEstimator::decomposeH(const cv::Mat &H, const cv::Mat &K, const Matri
             Vector3d e3(0, 0, 1);
             Vector3d n;
             cv::cv2eigen(cv_ns[i], n);
+            n.normalize();
             if(n.dot(e3) > 0)
                 positive_depth_transforms.push_back(Tr);
                 positive_depth_normals.push_back(n);
@@ -311,13 +312,13 @@ void MotionEstimator::decomposeH(const cv::Mat &H, const cv::Mat &K, const Matri
 
         Vector3d t;
         cv::cv2eigen(cv_ts[0], t);
-        Tr.block(0,3,3,1) = t;
+        Tr.block(0,3,3,1) = t.normalized();
 
         Vector3d n;
         cv::cv2eigen(cv_ns[0], n);
 
         //Tr = TrIC * Tr * TrIC.inverse();
         est_Tr = Tr.inverse().eval();
-        est_n = n;
+        est_n = n.normalized();
     }
 }
-- 
2.17.1


From 592df9a9008d83b575ec808197e53cfdf0084dff Mon Sep 17 00:00:00 2001
From: Karnik Ram <karnikram@gmail.com>
Date: Tue, 1 Dec 2020 11:28:04 +0530
Subject: [PATCH 15/42] Change K, avg parallax, and decomposition parameters

---
 feature_tracker/src/feature_tracker.cpp   |  2 +-
 vins_estimator/src/estimator.cpp          | 15 ++++++---------
 vins_estimator/src/initial/solve_5pts.cpp | 11 +++++++----
 3 files changed, 14 insertions(+), 14 deletions(-)

diff --git a/feature_tracker/src/feature_tracker.cpp b/feature_tracker/src/feature_tracker.cpp
index 4384928..50251ca 100644
--- a/feature_tracker/src/feature_tracker.cpp
+++ b/feature_tracker/src/feature_tracker.cpp
@@ -173,7 +173,7 @@ void FeatureTracker::readImage(const cv::Mat &_img, const cv::Mat &_mask, double
 
 void FeatureTracker::rejectWithF()
 {
-    if (forw_pts.size() >= 8)
+    if (forw_pts.size() >= 4)
     {
         ROS_DEBUG("FM ransac begins");
         TicToc t_f;
diff --git a/vins_estimator/src/estimator.cpp b/vins_estimator/src/estimator.cpp
index 5b302ea..d493036 100644
--- a/vins_estimator/src/estimator.cpp
+++ b/vins_estimator/src/estimator.cpp
@@ -275,12 +275,9 @@ bool Estimator::initialStructure()
         return false;
     }
     GlobalSFM sfm;
-    //if(!sfm.constructH(frame_count + 1, Q, T, l,
-    //          relative_R, relative_T, n,
-    //          sfm_f, sfm_tracked_points))
-    if(!sfm.construct(frame_count + 1, Q, T, l,
-                relative_R, relative_T,
-                sfm_f, sfm_tracked_points))
+    if(!sfm.constructH(frame_count + 1, Q, T, l,
+              relative_R, relative_T, n,
+              sfm_f, sfm_tracked_points))
     {
         ROS_DEBUG("global SFM failed!");
         marginalization_flag = MARGIN_OLD;
@@ -507,7 +504,7 @@ bool Estimator::relativeHPose(Matrix3d &relative_R, Vector3d &relative_T, Vector
             for(int k = WINDOW_SIZE - 1; k > i; k--)
                 R_imu = R_imu * (pre_integrations[k]->delta_q).toRotationMatrix();
 
-            if(average_parallax * 660 > 30 && m_estimator.solveRelativeHRT(corres, R_imu, TrIC, relative_R, relative_T, n))
+            if(average_parallax * 480 > 30 && m_estimator.solveRelativeHRT(corres, R_imu, TrIC, relative_R, relative_T, n))
             {
                 l = i;
                 ROS_DEBUG("average_parallax %f choose l %d and newest frame to triangulate the whole structure", average_parallax * 460, l);
@@ -811,8 +808,8 @@ void Estimator::optimization()
                 ProjectionFactor *f = new ProjectionFactor(pts_i, pts_j);
                 problem.AddResidualBlock(f, loss_function, para_Pose[imu_i], para_Pose[imu_j], para_Ex_Pose[0], para_Feature[feature_index]);
 
-                //ceres::CostFunction *h_cost_function = HomographyFactor::Create(pts_i, pts_j);
-                //problem.AddResidualBlock(h_cost_function, loss_function, para_Pose[imu_i], para_Pose[imu_j], para_N, para_Ex_Pose[0]);
+                ceres::CostFunction *h_cost_function = HomographyFactor::Create(pts_i, pts_j);
+                problem.AddResidualBlock(h_cost_function, loss_function, para_Pose[imu_i], para_Pose[imu_j], para_N, para_Ex_Pose[0]);
             }
             f_m_cnt++;
         }
diff --git a/vins_estimator/src/initial/solve_5pts.cpp b/vins_estimator/src/initial/solve_5pts.cpp
index 57485af..94a2a04 100644
--- a/vins_estimator/src/initial/solve_5pts.cpp
+++ b/vins_estimator/src/initial/solve_5pts.cpp
@@ -240,7 +240,8 @@ bool MotionEstimator::solveRelativeHRT(const vector<pair<Vector3d, Vector3d>> &c
         }
         cv::Mat mask;
         //cv::Mat E = cv::findFundamentalMat(ll, rr, cv::FM_RANSAC, 0.3 / 460, 0.99, mask);
-        cv::Mat H = cv::findHomography(ll, rr, cv::RANSAC, 0.3/665);
+        cv::Mat H = cv::findHomography(ll, rr, cv::RANSAC, 0.3/480);
+        //cv::Mat K = (cv::Mat_<double>(3, 3) << 320, 0, 320, 0, 320, 240, 0, 0, 1);
         cv::Mat K = (cv::Mat_<double>(3, 3) << 1, 0, 0, 0, 1, 0, 0, 0, 1);
         //cv::Mat K = (cv::Mat_<double>(3,3) << 665, 0, 511, 0, 665, 383, 0, 0, 1);
 
@@ -275,7 +276,7 @@ void MotionEstimator::decomposeH(const cv::Mat &H, const cv::Mat &K, const Matri
 
             Vector3d t;
             cv::cv2eigen(cv_ts[i], t);
-            Tr.block(0,3,3,1) = t.normalized();
+            Tr.block(0,3,3,1) = t;
 
             //Tr = TrIC * Tr * TrIC.inverse();
             Tr = Tr.inverse().eval();
@@ -285,8 +286,10 @@ void MotionEstimator::decomposeH(const cv::Mat &H, const cv::Mat &K, const Matri
             cv::cv2eigen(cv_ns[i], n);
             n.normalize();
             if(n.dot(e3) > 0)
+            {
                 positive_depth_transforms.push_back(Tr);
                 positive_depth_normals.push_back(n);
+            }
         }
 
         vector<double> rot_diff;
@@ -300,7 +303,7 @@ void MotionEstimator::decomposeH(const cv::Mat &H, const cv::Mat &K, const Matri
 
         int min_index = std::min_element(rot_diff.begin(), rot_diff.end()) - rot_diff.begin();
         est_Tr = positive_depth_transforms[min_index];
-        est_n = positive_depth_normals[min_index];
+        est_n = positive_depth_normals[min_index].normalized();
     }
 
     else
@@ -312,7 +315,7 @@ void MotionEstimator::decomposeH(const cv::Mat &H, const cv::Mat &K, const Matri
 
         Vector3d t;
         cv::cv2eigen(cv_ts[0], t);
-        Tr.block(0,3,3,1) = t.normalized();
+        Tr.block(0,3,3,1) = t;
 
         Vector3d n;
         cv::cv2eigen(cv_ns[0], n);
-- 
2.17.1


From 0cf646f9323df0d94551e541e1221febd4ad3e7a Mon Sep 17 00:00:00 2001
From: Karnik Ram <karnikram@gmail.com>
Date: Wed, 2 Dec 2020 08:17:02 +0530
Subject: [PATCH 16/42] Use h only for two-frame init

---
 config/vins_rviz_config.rviz     | 28 +++++++++++++++++++---------
 vins_estimator/src/estimator.cpp |  6 +++---
 2 files changed, 22 insertions(+), 12 deletions(-)

diff --git a/config/vins_rviz_config.rviz b/config/vins_rviz_config.rviz
index 92ff49d..55ed131 100644
--- a/config/vins_rviz_config.rviz
+++ b/config/vins_rviz_config.rviz
@@ -3,7 +3,8 @@ Panels:
     Help Height: 0
     Name: Displays
     Property Tree Widget:
-      Expanded: ~
+      Expanded:
+        - /VIO1
       Splitter Ratio: 0.4651159942150116
     Tree Height: 151
   - Class: rviz/Selection
@@ -24,7 +25,7 @@ Panels:
     Experimental: false
     Name: Time
     SyncMode: 0
-    SyncSource: ""
+    SyncSource: tracked image
   - Class: rviz/Displays
     Help Height: 78
     Name: Displays
@@ -141,7 +142,7 @@ Visualization Manager:
           Marker Topic: /vins_estimator/camera_pose_visual
           Name: camera_visual
           Namespaces:
-            {}
+            CameraPoseVisualization: true
           Queue Size: 100
           Value: true
         - Alpha: 1
@@ -186,7 +187,7 @@ Visualization Manager:
           Color: 255; 255; 255
           Color Transformer: FlatColor
           Decay Time: 3000
-          Enabled: false
+          Enabled: true
           Invert Rainbow: true
           Max Color: 0; 0; 0
           Max Intensity: 4096
@@ -203,19 +204,28 @@ Visualization Manager:
           Unreliable: false
           Use Fixed Frame: true
           Use rainbow: false
-          Value: false
+          Value: true
         - Class: rviz/TF
           Enabled: true
           Frame Timeout: 15
           Frames:
             All Enabled: true
+            body:
+              Value: true
+            camera:
+              Value: true
+            world:
+              Value: true
           Marker Scale: 1
           Name: TF
           Show Arrows: true
           Show Axes: true
           Show Names: true
           Tree:
-            {}
+            world:
+              body:
+                camera:
+                  {}
           Update Interval: 0
           Value: true
       Enabled: true
@@ -470,7 +480,7 @@ Visualization Manager:
   Views:
     Current:
       Class: rviz/XYOrbit
-      Distance: 20.968406677246094
+      Distance: 117.1939697265625
       Enable Stereo Rendering:
         Stereo Eye Separation: 0.05999999865889549
         Stereo Focal Distance: 1
@@ -485,10 +495,10 @@ Visualization Manager:
       Invert Z Axis: false
       Name: Current View
       Near Clip Distance: 0.009999999776482582
-      Pitch: 1.0797961950302124
+      Pitch: 0.01979677751660347
       Target Frame: <Fixed Frame>
       Value: XYOrbit (rviz)
-      Yaw: 3.087226629257202
+      Yaw: 3.0572268962860107
     Saved: ~
 Window Geometry:
   Displays:
diff --git a/vins_estimator/src/estimator.cpp b/vins_estimator/src/estimator.cpp
index d493036..84fa09e 100644
--- a/vins_estimator/src/estimator.cpp
+++ b/vins_estimator/src/estimator.cpp
@@ -275,8 +275,8 @@ bool Estimator::initialStructure()
         return false;
     }
     GlobalSFM sfm;
-    if(!sfm.constructH(frame_count + 1, Q, T, l,
-              relative_R, relative_T, n,
+    if(!sfm.construct(frame_count + 1, Q, T, l,
+              relative_R, relative_T,
               sfm_f, sfm_tracked_points))
     {
         ROS_DEBUG("global SFM failed!");
@@ -809,7 +809,7 @@ void Estimator::optimization()
                 problem.AddResidualBlock(f, loss_function, para_Pose[imu_i], para_Pose[imu_j], para_Ex_Pose[0], para_Feature[feature_index]);
 
                 ceres::CostFunction *h_cost_function = HomographyFactor::Create(pts_i, pts_j);
-                problem.AddResidualBlock(h_cost_function, loss_function, para_Pose[imu_i], para_Pose[imu_j], para_N, para_Ex_Pose[0]);
+                //problem.AddResidualBlock(h_cost_function, loss_function, para_Pose[imu_i], para_Pose[imu_j], para_N, para_Ex_Pose[0]);
             }
             f_m_cnt++;
         }
-- 
2.17.1


From d625b4dc0982f33cdd17d64620d40de34244f78c Mon Sep 17 00:00:00 2001
From: Karnik Ram <karnikram@gmail.com>
Date: Thu, 17 Dec 2020 13:42:40 +0530
Subject: [PATCH 17/42] Change to qn parameterization, with plane depth

---
 vins_estimator/src/estimator.cpp              | 22 +++++++++++-------
 vins_estimator/src/estimator.h                |  4 +++-
 vins_estimator/src/factor/homography_factor.h | 12 ++++++----
 vins_estimator/src/initial/initial_sfm.cpp    | 23 ++++++++++---------
 vins_estimator/src/initial/initial_sfm.h      |  4 ++--
 vins_estimator/src/initial/solve_5pts.cpp     |  4 +---
 6 files changed, 40 insertions(+), 29 deletions(-)

diff --git a/vins_estimator/src/estimator.cpp b/vins_estimator/src/estimator.cpp
index 84fa09e..7a5245c 100644
--- a/vins_estimator/src/estimator.cpp
+++ b/vins_estimator/src/estimator.cpp
@@ -275,17 +275,18 @@ bool Estimator::initialStructure()
         return false;
     }
     GlobalSFM sfm;
-    if(!sfm.construct(frame_count + 1, Q, T, l,
-              relative_R, relative_T,
+    if(!sfm.constructH(frame_count + 1, Q, T, l,
+              relative_R, relative_T, n,
               sfm_f, sfm_tracked_points))
     {
         ROS_DEBUG("global SFM failed!");
         marginalization_flag = MARGIN_OLD;
         return false;
     }
-    para_N[0] = n[0];
-    para_N[1] = n[1];
-    para_N[2] = n[2];
+    para_N[0] = 0;
+    para_N[1] = n[0];
+    para_N[2] = n[1];
+    para_N[3] = n[2];
 
     //solve pnp for all frame
     map<double, ImageFrame>::iterator frame_it;
@@ -400,7 +401,8 @@ bool Estimator::visualInitialAlign()
     f_manager.setRic(ric);
     f_manager.triangulate(Ps, &(TIC_TMP[0]), &(RIC[0]));
 
-    double s = (x.tail<1>())(0);
+    s = (x.tail<1>())(0);
+    para_s[0] = s;
     for (int i = 0; i <= WINDOW_SIZE; i++)
     {
         pre_integrations[i]->repropagate(Vector3d::Zero(), Bgs[i]);
@@ -504,7 +506,7 @@ bool Estimator::relativeHPose(Matrix3d &relative_R, Vector3d &relative_T, Vector
             for(int k = WINDOW_SIZE - 1; k > i; k--)
                 R_imu = R_imu * (pre_integrations[k]->delta_q).toRotationMatrix();
 
-            if(average_parallax * 480 > 30 && m_estimator.solveRelativeHRT(corres, R_imu, TrIC, relative_R, relative_T, n))
+            if(average_parallax * 460 > 30 && m_estimator.solveRelativeHRT(corres, R_imu, TrIC, relative_R, relative_T, n))
             {
                 l = i;
                 ROS_DEBUG("average_parallax %f choose l %d and newest frame to triangulate the whole structure", average_parallax * 460, l);
@@ -724,6 +726,10 @@ void Estimator::optimization()
         problem.AddParameterBlock(para_Pose[i], SIZE_POSE, local_parameterization);
         problem.AddParameterBlock(para_SpeedBias[i], SIZE_SPEEDBIAS);
     }
+
+    ceres::LocalParameterization *local_n_parameterization = new ceres::QuaternionParameterization();
+    problem.AddParameterBlock(para_N, 4, local_n_parameterization);
+
     for (int i = 0; i < NUM_OF_CAM; i++)
     {
         ceres::LocalParameterization *local_parameterization = new PoseLocalParameterization();
@@ -809,7 +815,7 @@ void Estimator::optimization()
                 problem.AddResidualBlock(f, loss_function, para_Pose[imu_i], para_Pose[imu_j], para_Ex_Pose[0], para_Feature[feature_index]);
 
                 ceres::CostFunction *h_cost_function = HomographyFactor::Create(pts_i, pts_j);
-                //problem.AddResidualBlock(h_cost_function, loss_function, para_Pose[imu_i], para_Pose[imu_j], para_N, para_Ex_Pose[0]);
+                problem.AddResidualBlock(h_cost_function, loss_function, para_Pose[imu_i], para_Pose[imu_j], para_N, para_Feature[feature_index], para_Ex_Pose[0]);
             }
             f_m_cnt++;
         }
diff --git a/vins_estimator/src/estimator.h b/vins_estimator/src/estimator.h
index f3feedf..ba73f41 100644
--- a/vins_estimator/src/estimator.h
+++ b/vins_estimator/src/estimator.h
@@ -79,6 +79,7 @@ class Estimator
     Vector3d Bas[(WINDOW_SIZE + 1)];
     Vector3d Bgs[(WINDOW_SIZE + 1)];
     double td;
+    double s;
 
     Matrix3d back_R0, last_R, last_R0;
     Vector3d back_P0, last_P, last_P0;
@@ -115,7 +116,8 @@ class Estimator
     double para_Retrive_Pose[SIZE_POSE];
     double para_Td[1][1];
     double para_Tr[1][1];
-    double para_N[3];
+    double para_N[4];
+    double para_s[1];
 
     int loop_window_index;
 
diff --git a/vins_estimator/src/factor/homography_factor.h b/vins_estimator/src/factor/homography_factor.h
index 2a35d40..2fdccb5 100644
--- a/vins_estimator/src/factor/homography_factor.h
+++ b/vins_estimator/src/factor/homography_factor.h
@@ -7,7 +7,7 @@ struct HomographyFactor
     HomographyFactor(const Eigen::Vector3d &_pts_i, const Eigen::Vector3d &_pts_j) : pts_i(_pts_i), pts_j(_pts_j) {}
 
     template <typename T>
-        bool operator()(const T* const pose_i, const T* const pose_j, const T* const para_n, const T* const ex_pose, 
+        bool operator()(const T* const pose_i, const T* const pose_j, const T* const para_n, const T* const para_inv_depth, const T* const ex_pose, 
         T* residuals) const
         {
             Eigen::Map<const Eigen::Matrix<T, 3, 1>> pi(pose_i);
@@ -22,14 +22,18 @@ struct HomographyFactor
             Eigen::Quaternion<T> qic;
             qic.coeffs() << ex_pose[3], ex_pose[4], ex_pose[5], ex_pose[6];
 
-            Eigen::Map<const Eigen::Matrix<T, 3, 1>> n(para_n);
+            Eigen::Map<const Eigen::Matrix<T, 4, 1>> q_n(para_n);
+            Eigen::Matrix<T, 3, 1> n;
+            n << q_n[1], q_n[2], q_n[3];
             Eigen::Matrix<T, 3, 1> n_imu_1 = qic*(n.normalized()) + tic;
             Eigen::Matrix<T, 3, 1> n_imu_i = qi.inverse()*n_imu_1 - qi.inverse()*pi;
 
+            Eigen::Map<const Eigen::Matrix<T, 1, 1>> inv_depth(para_inv_depth);
+
             Eigen::Quaternion<T> qji = qj.inverse() * qi;
             Eigen::Matrix<T, 3, 1> tji = qj.inverse() * (pi - pj);
             Eigen::Matrix<T, 3, 1> pts_imu_i = qic * pts_i.cast<T>() + tic;
-            Eigen::Matrix<T, 3, 1> pts_imu_j = qji * pts_imu_i + tji * n_imu_i.transpose() * pts_imu_i;
+            Eigen::Matrix<T, 3, 1> pts_imu_j = qji * pts_imu_i + ((tji*inv_depth[0]) * n_imu_i.transpose()) * pts_imu_i;
             Eigen::Matrix<T, 3, 1> pts_cam_j = qic.inverse() * (pts_imu_j - tic);
 
             pts_cam_j = (pts_cam_j / pts_cam_j[2]);
@@ -41,7 +45,7 @@ struct HomographyFactor
 
     static ceres::CostFunction* Create(const Eigen::Vector3d &_pts_i, const Eigen::Vector3d &_pts_j)
     {
-        return (new ceres::AutoDiffCostFunction<HomographyFactor, 2, 7, 7, 3, 7>
+        return (new ceres::AutoDiffCostFunction<HomographyFactor, 2, 7, 7, 4, 1, 7>
                 (new HomographyFactor(_pts_i, _pts_j)));
     }
 
diff --git a/vins_estimator/src/initial/initial_sfm.cpp b/vins_estimator/src/initial/initial_sfm.cpp
index 76a4f88..2877082 100644
--- a/vins_estimator/src/initial/initial_sfm.cpp
+++ b/vins_estimator/src/initial/initial_sfm.cpp
@@ -342,7 +342,7 @@ bool GlobalSFM::constructH(int frame_num, Quaterniond* q, Vector3d* T, int l,
 	Quaterniond c_Quat[frame_num];
 	double c_rotation[frame_num][4];
 	double c_translation[frame_num][3];
-    double c_normal[3];
+    double c_normal[4];
 	Eigen::Matrix<double, 3, 4> Pose[frame_num];
 
 	c_Quat[l] = q[l].inverse();
@@ -462,10 +462,11 @@ bool GlobalSFM::constructH(int frame_num, Quaterniond* q, Vector3d* T, int l,
 		}
 	}
 
-    c_normal[0] = n[0];
-    c_normal[1] = n[1];
-    c_normal[2] = n[2];
-    problem.AddParameterBlock(c_normal, 3);
+	c_normal[0] = 0;
+    c_normal[1] = n[0];
+    c_normal[2] = n[1];
+    c_normal[3] = n[2];
+    problem.AddParameterBlock(c_normal, 4, local_parameterization);
 
 	for (int i = 0; i < feature_num; i++)
 	{
@@ -479,14 +480,14 @@ bool GlobalSFM::constructH(int frame_num, Quaterniond* q, Vector3d* T, int l,
 												sfm_f[i].observation[j].second.x(),
 												sfm_f[i].observation[j].second.y());
 
-    		problem.AddResidualBlock(b_cost_function, NULL, c_rotation[l], c_translation[l],
-    								sfm_f[i].position); 
+    		//problem.AddResidualBlock(b_cost_function, NULL, c_rotation[l], c_translation[l],
+    		//						sfm_f[i].position); 
 
 			ceres::CostFunction* h_cost_function = ReprojectionErrorH::Create(
 												sfm_f[i].observation[j].second.x(),
 												sfm_f[i].observation[j].second.y());
 
-    		problem.AddResidualBlock(h_cost_function, NULL, c_rotation[l], c_translation[l], c_normal, sfm_f[i].image);
+    		problem.AddResidualBlock(h_cost_function, NULL, c_rotation[l], c_translation[l], c_normal, sfm_f[i].position);
 		}
 	}
 	ceres::Solver::Options options;
@@ -526,9 +527,9 @@ bool GlobalSFM::constructH(int frame_num, Quaterniond* q, Vector3d* T, int l,
 			sfm_tracked_points[sfm_f[i].id] = Vector3d(sfm_f[i].position[0], sfm_f[i].position[1], sfm_f[i].position[2]);
 	}
 
-    n[0] = c_normal[0];
-    n[1] = c_normal[1];
-    n[2] = c_normal[2];
+    n[0] = c_normal[1];
+    n[1] = c_normal[2];
+    n[2] = c_normal[3];
 
 	return true;
 
diff --git a/vins_estimator/src/initial/initial_sfm.h b/vins_estimator/src/initial/initial_sfm.h
index e79dcea..f191434 100644
--- a/vins_estimator/src/initial/initial_sfm.h
+++ b/vins_estimator/src/initial/initial_sfm.h
@@ -66,7 +66,7 @@ struct ReprojectionErrorH
 	{
 		T p[3];
         ceres::QuaternionRotatePoint(R, point, p);
-        T np = n[0] * point[0] + n[1] * point[1] + n[2] * point[2];
+        T np = n[1] * point[0] + n[2] * point[1] + n[3] * point[2];
         p[0] += t[0]*np; p[1] += t[1]*np; p[2] += t[2]*np;
 		T xp = p[0] / p[2];
     	T yp = p[1] / p[2];
@@ -79,7 +79,7 @@ struct ReprojectionErrorH
 	                                   const double observed_y) 
 	{
 	  return (new ceres::AutoDiffCostFunction<
-	          ReprojectionErrorH, 2, 4, 3, 3, 3>(
+	          ReprojectionErrorH, 2, 4, 3, 4, 3>(
 	          	new ReprojectionErrorH(observed_x,observed_y)));
 	}
 
diff --git a/vins_estimator/src/initial/solve_5pts.cpp b/vins_estimator/src/initial/solve_5pts.cpp
index 94a2a04..d05faa5 100644
--- a/vins_estimator/src/initial/solve_5pts.cpp
+++ b/vins_estimator/src/initial/solve_5pts.cpp
@@ -241,9 +241,7 @@ bool MotionEstimator::solveRelativeHRT(const vector<pair<Vector3d, Vector3d>> &c
         cv::Mat mask;
         //cv::Mat E = cv::findFundamentalMat(ll, rr, cv::FM_RANSAC, 0.3 / 460, 0.99, mask);
         cv::Mat H = cv::findHomography(ll, rr, cv::RANSAC, 0.3/480);
-        //cv::Mat K = (cv::Mat_<double>(3, 3) << 320, 0, 320, 0, 320, 240, 0, 0, 1);
         cv::Mat K = (cv::Mat_<double>(3, 3) << 1, 0, 0, 0, 1, 0, 0, 0, 1);
-        //cv::Mat K = (cv::Mat_<double>(3,3) << 665, 0, 511, 0, 665, 383, 0, 0, 1);
 
         Eigen::Matrix4d est_Tr;
         Eigen::Vector3d est_n;
@@ -303,7 +301,7 @@ void MotionEstimator::decomposeH(const cv::Mat &H, const cv::Mat &K, const Matri
 
         int min_index = std::min_element(rot_diff.begin(), rot_diff.end()) - rot_diff.begin();
         est_Tr = positive_depth_transforms[min_index];
-        est_n = positive_depth_normals[min_index].normalized();
+        est_n = positive_depth_normals[min_index];
     }
 
     else
-- 
2.17.1


From 208ef88ed7f9fc41793852797b86c3d411f1c1e4 Mon Sep 17 00:00:00 2001
From: Karnik Ram <karnikram@gmail.com>
Date: Fri, 1 Jan 2021 12:53:32 +0530
Subject: [PATCH 18/42] Use mean point vector to disambiguate H, change
 thresholds

---
 feature_tracker/src/feature_tracker.cpp   |  2 +-
 vins_estimator/src/initial/solve_5pts.cpp | 20 ++++++++++++++++----
 vins_estimator/src/initial/solve_5pts.h   |  2 +-
 3 files changed, 18 insertions(+), 6 deletions(-)

diff --git a/feature_tracker/src/feature_tracker.cpp b/feature_tracker/src/feature_tracker.cpp
index 50251ca..afc174e 100644
--- a/feature_tracker/src/feature_tracker.cpp
+++ b/feature_tracker/src/feature_tracker.cpp
@@ -194,7 +194,7 @@ void FeatureTracker::rejectWithF()
 
         vector<uchar> status;
         //cv::findFundamentalMat(un_cur_pts, un_forw_pts, cv::FM_RANSAC, F_THRESHOLD, 0.99, status);
-        cv::findHomography(un_cur_pts, un_forw_pts, cv::RANSAC, 3, status);
+        cv::findHomography(un_cur_pts, un_forw_pts, cv::RANSAC, 0.99, status);
         int size_a = cur_pts.size();
         reduceVector(prev_pts, status);
         reduceVector(cur_pts, status);
diff --git a/vins_estimator/src/initial/solve_5pts.cpp b/vins_estimator/src/initial/solve_5pts.cpp
index d05faa5..f86c2bf 100644
--- a/vins_estimator/src/initial/solve_5pts.cpp
+++ b/vins_estimator/src/initial/solve_5pts.cpp
@@ -240,12 +240,23 @@ bool MotionEstimator::solveRelativeHRT(const vector<pair<Vector3d, Vector3d>> &c
         }
         cv::Mat mask;
         //cv::Mat E = cv::findFundamentalMat(ll, rr, cv::FM_RANSAC, 0.3 / 460, 0.99, mask);
-        cv::Mat H = cv::findHomography(ll, rr, cv::RANSAC, 0.3/480);
+        cv::Mat H = cv::findHomography(ll, rr, cv::RANSAC, 0.3/460);
         cv::Mat K = (cv::Mat_<double>(3, 3) << 1, 0, 0, 0, 1, 0, 0, 0, 1);
 
+        // Compute mean point vector
+        Eigen::Vector3d mean_l(0, 0, 1);
+        for(cv::Point2f &point : ll)
+        {
+            mean_l(0) += point.x;
+            mean_l(1) += point.y;
+        }
+
+        mean_l(0) /= int(ll.size());
+        mean_l(1) /= int(ll.size());
+
         Eigen::Matrix4d est_Tr;
         Eigen::Vector3d est_n;
-        decomposeH(H, K, R_imu, TrIC, est_Tr, est_n);
+        decomposeH(H, K, R_imu, TrIC, mean_l, est_Tr, est_n);
         Rotation = est_Tr.block(0,0,3,3);
         Translation = est_Tr.block(0,3,3,1);
         n = est_n;
@@ -255,7 +266,8 @@ bool MotionEstimator::solveRelativeHRT(const vector<pair<Vector3d, Vector3d>> &c
 }
 
 
-void MotionEstimator::decomposeH(const cv::Mat &H, const cv::Mat &K, const Matrix3d &R_imu, const Matrix4d &TrIC, Matrix4d &est_Tr, Vector3d &est_n)
+void MotionEstimator::decomposeH(const cv::Mat &H, const cv::Mat &K, const Matrix3d &R_imu, 
+    const Matrix4d &TrIC, const Vector3d &mean_l, Matrix4d &est_Tr, Vector3d &est_n)
 {
     vector<cv::Mat> cv_Rs, cv_ts, cv_ns;
     int n_sols = cv::decomposeHomographyMat(H, K, cv_Rs, cv_ts, cv_ns);
@@ -283,7 +295,7 @@ void MotionEstimator::decomposeH(const cv::Mat &H, const cv::Mat &K, const Matri
             Vector3d n;
             cv::cv2eigen(cv_ns[i], n);
             n.normalize();
-            if(n.dot(e3) > 0)
+            if(n.dot(mean_l) > 0)
             {
                 positive_depth_transforms.push_back(Tr);
                 positive_depth_normals.push_back(n);
diff --git a/vins_estimator/src/initial/solve_5pts.h b/vins_estimator/src/initial/solve_5pts.h
index f090370..0da7ba2 100644
--- a/vins_estimator/src/initial/solve_5pts.h
+++ b/vins_estimator/src/initial/solve_5pts.h
@@ -16,7 +16,7 @@ class MotionEstimator
 
     bool solveRelativeRT(const vector<pair<Vector3d, Vector3d>> &corres, Matrix3d &R, Vector3d &T);
     bool solveRelativeHRT(const vector<pair<Vector3d, Vector3d>> &corres, const Matrix3d &R_imu, const Matrix4d &TrIC, Matrix3d &R, Vector3d &T, Vector3d &n);
-    void decomposeH(const cv::Mat &H, const cv::Mat &K, const Matrix3d &R_imu, const  Matrix4d &TrIC, Matrix4d &est_Tr, Vector3d &est_n);
+    void decomposeH(const cv::Mat &H, const cv::Mat &K, const Matrix3d &R_imu, const  Matrix4d &TrIC, const Vector3d &mean_l, Matrix4d &est_Tr, Vector3d &est_n);
 
   private:
     double testTriangulation(const vector<cv::Point2f> &l,
-- 
2.17.1


From c3c81a017e2a2ecf8d54ce1efacc0e602a8bea3a Mon Sep 17 00:00:00 2001
From: Karnik Ram <karnikram@gmail.com>
Date: Fri, 1 Jan 2021 12:56:14 +0530
Subject: [PATCH 19/42] Propogate plane-d from initial window, instead of using
 per-point depth

---
 vins_estimator/src/estimator.cpp              | 5 ++---
 vins_estimator/src/estimator.h                | 2 +-
 vins_estimator/src/factor/homography_factor.h | 4 +++-
 3 files changed, 6 insertions(+), 5 deletions(-)

diff --git a/vins_estimator/src/estimator.cpp b/vins_estimator/src/estimator.cpp
index 7a5245c..7105514 100644
--- a/vins_estimator/src/estimator.cpp
+++ b/vins_estimator/src/estimator.cpp
@@ -402,7 +402,7 @@ bool Estimator::visualInitialAlign()
     f_manager.triangulate(Ps, &(TIC_TMP[0]), &(RIC[0]));
 
     s = (x.tail<1>())(0);
-    para_s[0] = s;
+    para_d[0] = s;
     for (int i = 0; i <= WINDOW_SIZE; i++)
     {
         pre_integrations[i]->repropagate(Vector3d::Zero(), Bgs[i]);
@@ -462,7 +462,6 @@ bool Estimator::relativePose(Matrix3d &relative_R, Vector3d &relative_T, int &l)
                 Vector2d pts_1(corres[j].second(0), corres[j].second(1));
                 double parallax = (pts_0 - pts_1).norm();
                 sum_parallax = sum_parallax + parallax;
-
             }
             average_parallax = 1.0 * sum_parallax / int(corres.size());
             if(average_parallax * 460 > 30 && m_estimator.solveRelativeRT(corres, relative_R, relative_T))
@@ -815,7 +814,7 @@ void Estimator::optimization()
                 problem.AddResidualBlock(f, loss_function, para_Pose[imu_i], para_Pose[imu_j], para_Ex_Pose[0], para_Feature[feature_index]);
 
                 ceres::CostFunction *h_cost_function = HomographyFactor::Create(pts_i, pts_j);
-                problem.AddResidualBlock(h_cost_function, loss_function, para_Pose[imu_i], para_Pose[imu_j], para_N, para_Feature[feature_index], para_Ex_Pose[0]);
+                problem.AddResidualBlock(h_cost_function, loss_function, para_Pose[imu_i], para_Pose[imu_j], para_N, para_d, para_Ex_Pose[0]);
             }
             f_m_cnt++;
         }
diff --git a/vins_estimator/src/estimator.h b/vins_estimator/src/estimator.h
index ba73f41..adad3cd 100644
--- a/vins_estimator/src/estimator.h
+++ b/vins_estimator/src/estimator.h
@@ -117,7 +117,7 @@ class Estimator
     double para_Td[1][1];
     double para_Tr[1][1];
     double para_N[4];
-    double para_s[1];
+    double para_d[1];
 
     int loop_window_index;
 
diff --git a/vins_estimator/src/factor/homography_factor.h b/vins_estimator/src/factor/homography_factor.h
index 2fdccb5..ce6612b 100644
--- a/vins_estimator/src/factor/homography_factor.h
+++ b/vins_estimator/src/factor/homography_factor.h
@@ -32,8 +32,10 @@ struct HomographyFactor
 
             Eigen::Quaternion<T> qji = qj.inverse() * qi;
             Eigen::Matrix<T, 3, 1> tji = qj.inverse() * (pi - pj);
+            Eigen::Matrix<T, 1, 1> di;
+            di(0,0) = inv_depth(0,0) - pi.dot(n_imu_i);
             Eigen::Matrix<T, 3, 1> pts_imu_i = qic * pts_i.cast<T>() + tic;
-            Eigen::Matrix<T, 3, 1> pts_imu_j = qji * pts_imu_i + ((tji*inv_depth[0]) * n_imu_i.transpose()) * pts_imu_i;
+            Eigen::Matrix<T, 3, 1> pts_imu_j = qji * pts_imu_i + (tji*(1.0/di(0,0)) * n_imu_i.transpose()) * pts_imu_i;
             Eigen::Matrix<T, 3, 1> pts_cam_j = qic.inverse() * (pts_imu_j - tic);
 
             pts_cam_j = (pts_cam_j / pts_cam_j[2]);
-- 
2.17.1


From c9f6349946574ca616acb11987d76d40055e59cf Mon Sep 17 00:00:00 2001
From: Karnik Ram <karnikram@gmail.com>
Date: Thu, 7 Jan 2021 11:05:10 +0530
Subject: [PATCH 20/42] Revert to previous thresholds

---
 feature_tracker/src/feature_tracker.cpp    |  2 +-
 vins_estimator/src/estimator.cpp           |  2 --
 vins_estimator/src/initial/initial_sfm.cpp |  4 ++--
 vins_estimator/src/initial/initial_sfm.h   | 10 +++++-----
 vins_estimator/src/initial/solve_5pts.cpp  |  2 +-
 5 files changed, 9 insertions(+), 11 deletions(-)

diff --git a/feature_tracker/src/feature_tracker.cpp b/feature_tracker/src/feature_tracker.cpp
index afc174e..50251ca 100644
--- a/feature_tracker/src/feature_tracker.cpp
+++ b/feature_tracker/src/feature_tracker.cpp
@@ -194,7 +194,7 @@ void FeatureTracker::rejectWithF()
 
         vector<uchar> status;
         //cv::findFundamentalMat(un_cur_pts, un_forw_pts, cv::FM_RANSAC, F_THRESHOLD, 0.99, status);
-        cv::findHomography(un_cur_pts, un_forw_pts, cv::RANSAC, 0.99, status);
+        cv::findHomography(un_cur_pts, un_forw_pts, cv::RANSAC, 3, status);
         int size_a = cur_pts.size();
         reduceVector(prev_pts, status);
         reduceVector(cur_pts, status);
diff --git a/vins_estimator/src/estimator.cpp b/vins_estimator/src/estimator.cpp
index 7105514..bfa5c1e 100644
--- a/vins_estimator/src/estimator.cpp
+++ b/vins_estimator/src/estimator.cpp
@@ -779,7 +779,6 @@ void Estimator::optimization()
         int imu_i = it_per_id.start_frame, imu_j = imu_i - 1;
         
         Vector3d pts_i = it_per_id.feature_per_frame[0].point;
-        Vector3d img_pts_i(it_per_id.feature_per_frame[0].uv.x(), it_per_id.feature_per_frame[0].uv.y(), 1);
 
         for (auto &it_per_frame : it_per_id.feature_per_frame)
         {
@@ -790,7 +789,6 @@ void Estimator::optimization()
             }
 
             Vector3d pts_j = it_per_frame.point;
-            Vector3d img_pts_j(it_per_frame.uv.x(), it_per_frame.uv.y(), 1);
 
             if (ESTIMATE_TD)
             {
diff --git a/vins_estimator/src/initial/initial_sfm.cpp b/vins_estimator/src/initial/initial_sfm.cpp
index 2877082..ad9f729 100644
--- a/vins_estimator/src/initial/initial_sfm.cpp
+++ b/vins_estimator/src/initial/initial_sfm.cpp
@@ -480,8 +480,8 @@ bool GlobalSFM::constructH(int frame_num, Quaterniond* q, Vector3d* T, int l,
 												sfm_f[i].observation[j].second.x(),
 												sfm_f[i].observation[j].second.y());
 
-    		//problem.AddResidualBlock(b_cost_function, NULL, c_rotation[l], c_translation[l],
-    		//						sfm_f[i].position); 
+    		problem.AddResidualBlock(b_cost_function, NULL, c_rotation[l], c_translation[l],
+    								sfm_f[i].position); 
 
 			ceres::CostFunction* h_cost_function = ReprojectionErrorH::Create(
 												sfm_f[i].observation[j].second.x(),
diff --git a/vins_estimator/src/initial/initial_sfm.h b/vins_estimator/src/initial/initial_sfm.h
index f191434..a070742 100644
--- a/vins_estimator/src/initial/initial_sfm.h
+++ b/vins_estimator/src/initial/initial_sfm.h
@@ -64,12 +64,12 @@ struct ReprojectionErrorH
 	template <typename T>
 	bool operator()(const T* const R, const T* const t, const T* const n, const T* point, T* residuals) const
 	{
-		T p[3];
-        ceres::QuaternionRotatePoint(R, point, p);
+		T rp[3];
+        ceres::QuaternionRotatePoint(R, point, rp);
         T np = n[1] * point[0] + n[2] * point[1] + n[3] * point[2];
-        p[0] += t[0]*np; p[1] += t[1]*np; p[2] += t[2]*np;
-		T xp = p[0] / p[2];
-    	T yp = p[1] / p[2];
+        rp[0] += t[0]*np; rp[1] += t[1]*np; rp[2] += t[2]*np;
+		T xp = rp[0] / rp[2];
+    	T yp = rp[1] / rp[2];
     	residuals[0] = xp - T(observed_u);
     	residuals[1] = yp - T(observed_v);
     	return true;
diff --git a/vins_estimator/src/initial/solve_5pts.cpp b/vins_estimator/src/initial/solve_5pts.cpp
index f86c2bf..a14ec1c 100644
--- a/vins_estimator/src/initial/solve_5pts.cpp
+++ b/vins_estimator/src/initial/solve_5pts.cpp
@@ -240,7 +240,7 @@ bool MotionEstimator::solveRelativeHRT(const vector<pair<Vector3d, Vector3d>> &c
         }
         cv::Mat mask;
         //cv::Mat E = cv::findFundamentalMat(ll, rr, cv::FM_RANSAC, 0.3 / 460, 0.99, mask);
-        cv::Mat H = cv::findHomography(ll, rr, cv::RANSAC, 0.3/460);
+        cv::Mat H = cv::findHomography(ll, rr, cv::RANSAC, 0.3/480);
         cv::Mat K = (cv::Mat_<double>(3, 3) << 1, 0, 0, 0, 1, 0, 0, 0, 1);
 
         // Compute mean point vector
-- 
2.17.1


From 2c6255f97f3f02da71082d34e861befc5e9accec Mon Sep 17 00:00:00 2001
From: Karnik Ram <karnikram@gmail.com>
Date: Fri, 8 Jan 2021 11:40:55 +0530
Subject: [PATCH 21/42] Add code for generic mask to single mask conversion

---
 feature_tracker/src/feature_tracker.cpp      | 40 ++++++++++++++++++--
 feature_tracker/src/feature_tracker_node.cpp |  2 +-
 2 files changed, 37 insertions(+), 5 deletions(-)

diff --git a/feature_tracker/src/feature_tracker.cpp b/feature_tracker/src/feature_tracker.cpp
index 50251ca..178a7a7 100644
--- a/feature_tracker/src/feature_tracker.cpp
+++ b/feature_tracker/src/feature_tracker.cpp
@@ -28,7 +28,6 @@ void reduceVector(vector<int> &v, vector<uchar> status)
     v.resize(j);
 }
 
-
 FeatureTracker::FeatureTracker()
 {
 }
@@ -70,11 +69,44 @@ void FeatureTracker::setMask()
 
 void FeatureTracker::addPoints(const cv::Mat &_mask)
 {
-    cv::Mat dynamic_mask;
-    cv::erode(_mask, dynamic_mask, cv::Mat(), cv::Point(-1, -1), 2, 1, 1);
+    // Find unique labels
+    cv::Mat mask_copy = _mask.clone();
+    std::sort(mask_copy.begin<uchar>(), mask_copy.end<uchar>());
+    auto last = std::unique(mask_copy.begin<uchar>(), mask_copy.end<uchar>());
+    std::vector<uchar> unique_labels(mask_copy.begin<uchar>(), last);
+
+    // Create mask for each label and erode, find largest mask
+    std::map<uchar, cv::Mat> unique_masks;
+    for(auto &label : unique_labels)
+    {
+        unique_masks.emplace(label, cv::Mat::zeros(_mask.size(), CV_8UC1));
+        std::cout << int(label) << std::endl;
+    }
+
+    for(int i = 0; i < _mask.rows; i++)
+        for(int j = 0; j < _mask.cols; j++)
+            unique_masks[_mask.at<uchar>(i,j)].at<uchar>(i,j) = 255;
+
+    uchar largest_label = 0;
+    int largest_label_count = 0;
+    for(auto &mask : unique_masks)
+    {   
+        if(mask.first == 0)
+            continue;
+        cv::erode(mask.second, mask.second, cv::Mat(), cv::Point(-1, -1), 2, 1, 1);
+        mask.second);
+        int label_count = cv::countNonZero(mask.second);
+        if(label_count > largest_label_count)
+        {
+            largest_label_count = label_count;
+            largest_label = mask.first;
+        }
+    }
+
+    // Track features that only belong to largest mask
     for (auto &p : n_pts)
     {
-        if(dynamic_mask.at<uchar>(p) == 255)
+        if(unique_masks[largest_label].at<uchar>(p) == 255)
         {
             forw_pts.push_back(p);
             ids.push_back(-1);
diff --git a/feature_tracker/src/feature_tracker_node.cpp b/feature_tracker/src/feature_tracker_node.cpp
index a0dbd25..d1a9432 100644
--- a/feature_tracker/src/feature_tracker_node.cpp
+++ b/feature_tracker/src/feature_tracker_node.cpp
@@ -86,7 +86,7 @@ void callback(const sensor_msgs::ImageConstPtr &img_msg, const sensor_msgs::Imag
     {
         ROS_DEBUG("processing camera %d", i);
         if (i != 1 || !STEREO_TRACK)
-            trackerData[i].readImage(ptr->image.rowRange(ROW * i, ROW * (i + 1)), mask_ptr->image, img_msg->header.stamp.toSec());
+            trackerData[i].readImage(ptr->image.rowRange(ROW * i, ROW * (i + 1)), mask_ptr->image.rowRange(ROW*i,ROW*(i+1)), img_msg->header.stamp.toSec());
         else
         {
             if (EQUALIZE)
-- 
2.17.1


From cb655fa6061ceb11c7ae7fbddd11af779d738430 Mon Sep 17 00:00:00 2001
From: Karnik Ram <karnikram@gmail.com>
Date: Wed, 13 Jan 2021 11:48:28 +0530
Subject: [PATCH 22/42] Publish plane id for each feature

---
 feature_tracker/src/feature_tracker.cpp      | 58 ++++++++++----------
 feature_tracker/src/feature_tracker.h        |  1 +
 feature_tracker/src/feature_tracker_node.cpp | 10 +++-
 3 files changed, 37 insertions(+), 32 deletions(-)

diff --git a/feature_tracker/src/feature_tracker.cpp b/feature_tracker/src/feature_tracker.cpp
index 178a7a7..0de4262 100644
--- a/feature_tracker/src/feature_tracker.cpp
+++ b/feature_tracker/src/feature_tracker.cpp
@@ -41,26 +41,31 @@ void FeatureTracker::setMask()
     
 
     // prefer to keep features that are tracked for long time
-    vector<pair<int, pair<cv::Point2f, int>>> cnt_pts_id;
+    vector<pair<int, pair<cv::Point2f, pair<int,int>>>> cnt_pts_id_pid;
 
     for (unsigned int i = 0; i < forw_pts.size(); i++)
-        cnt_pts_id.push_back(make_pair(track_cnt[i], make_pair(forw_pts[i], ids[i])));
+        cnt_pts_id_pid.push_back(make_pair(track_cnt[i], 
+            make_pair(forw_pts[i], make_pair(ids[i], plane_ids[i]))));
 
-    sort(cnt_pts_id.begin(), cnt_pts_id.end(), [](const pair<int, pair<cv::Point2f, int>> &a, const pair<int, pair<cv::Point2f, int>> &b)
+    sort(cnt_pts_id_pid.begin(), cnt_pts_id_pid.end(), 
+        [](const pair<int, pair<cv::Point2f, pair<int,int>>> &a, 
+            const pair<int, pair<cv::Point2f, pair<int,int>>> &b)
          {
             return a.first > b.first;
          });
 
     forw_pts.clear();
     ids.clear();
+    plane_ids.clear();
     track_cnt.clear();
 
-    for (auto &it : cnt_pts_id)
+    for (auto &it : cnt_pts_id_pid)
     {
         if (mask.at<uchar>(it.second.first) == 255)
         {
             forw_pts.push_back(it.second.first);
-            ids.push_back(it.second.second);
+            ids.push_back(it.second.second.first);
+            plane_ids.push_back(it.second.second.second);
             track_cnt.push_back(it.first);
             cv::circle(mask, it.second.first, MIN_DIST, 0, -1);
         }
@@ -75,42 +80,35 @@ void FeatureTracker::addPoints(const cv::Mat &_mask)
     auto last = std::unique(mask_copy.begin<uchar>(), mask_copy.end<uchar>());
     std::vector<uchar> unique_labels(mask_copy.begin<uchar>(), last);
 
-    // Create mask for each label and erode, find largest mask
+    // Create mask for each label
     std::map<uchar, cv::Mat> unique_masks;
     for(auto &label : unique_labels)
-    {
         unique_masks.emplace(label, cv::Mat::zeros(_mask.size(), CV_8UC1));
-        std::cout << int(label) << std::endl;
-    }
 
     for(int i = 0; i < _mask.rows; i++)
         for(int j = 0; j < _mask.cols; j++)
             unique_masks[_mask.at<uchar>(i,j)].at<uchar>(i,j) = 255;
 
-    uchar largest_label = 0;
-    int largest_label_count = 0;
-    for(auto &mask : unique_masks)
-    {   
-        if(mask.first == 0)
-            continue;
-        cv::erode(mask.second, mask.second, cv::Mat(), cv::Point(-1, -1), 2, 1, 1);
-        mask.second);
-        int label_count = cv::countNonZero(mask.second);
-        if(label_count > largest_label_count)
-        {
-            largest_label_count = label_count;
-            largest_label = mask.first;
-        }
-    }
+    // Erode each mask to avoid dynamic edges
+    for(auto &unique_mask : unique_masks)
+        cv::erode(unique_mask.second, unique_mask.second, cv::Mat(), cv::Point(-1, -1), 2, 1, 1);
 
-    // Track features that only belong to largest mask
+    // Store plane id for each feature
     for (auto &p : n_pts)
     {
-        if(unique_masks[largest_label].at<uchar>(p) == 255)
+        for(auto &unique_mask : unique_masks)
         {
-            forw_pts.push_back(p);
-            ids.push_back(-1);
-            track_cnt.push_back(1);
+            if(unique_mask.first == 0)
+                continue;
+                
+            if(unique_mask.second.at<uchar>(p) == 255)
+            {
+                forw_pts.push_back(p);
+                ids.push_back(-1);
+                track_cnt.push_back(1);
+                plane_ids.push_back(unique_mask.first);
+                break;
+            }
         }
     }
 }
@@ -156,6 +154,7 @@ void FeatureTracker::readImage(const cv::Mat &_img, const cv::Mat &_mask, double
         reduceVector(cur_pts, status);
         reduceVector(forw_pts, status);
         reduceVector(ids, status);
+        reduceVector(plane_ids, status);
         reduceVector(cur_un_pts, status);
         reduceVector(track_cnt, status);
         ROS_DEBUG("temporal optical flow costs: %fms", t_o.toc());
@@ -233,6 +232,7 @@ void FeatureTracker::rejectWithF()
         reduceVector(forw_pts, status);
         reduceVector(cur_un_pts, status);
         reduceVector(ids, status);
+        reduceVector(plane_ids, status);
         reduceVector(track_cnt, status);
         ROS_DEBUG("FM ransac: %d -> %lu: %f", size_a, forw_pts.size(), 1.0 * forw_pts.size() / size_a);
         ROS_DEBUG("FM ransac costs: %fms", t_f.toc());
diff --git a/feature_tracker/src/feature_tracker.h b/feature_tracker/src/feature_tracker.h
index c98c7ac..5db3810 100644
--- a/feature_tracker/src/feature_tracker.h
+++ b/feature_tracker/src/feature_tracker.h
@@ -54,6 +54,7 @@ class FeatureTracker
     vector<cv::Point2f> prev_un_pts, cur_un_pts;
     vector<cv::Point2f> pts_velocity;
     vector<int> ids;
+    vector<int> plane_ids;
     vector<int> track_cnt;
     map<int, cv::Point2f> cur_un_pts_map;
     map<int, cv::Point2f> prev_un_pts_map;
diff --git a/feature_tracker/src/feature_tracker_node.cpp b/feature_tracker/src/feature_tracker_node.cpp
index d1a9432..b9de94a 100644
--- a/feature_tracker/src/feature_tracker_node.cpp
+++ b/feature_tracker/src/feature_tracker_node.cpp
@@ -118,6 +118,7 @@ void callback(const sensor_msgs::ImageConstPtr &img_msg, const sensor_msgs::Imag
         pub_count++;
         sensor_msgs::PointCloudPtr feature_points(new sensor_msgs::PointCloud);
         sensor_msgs::ChannelFloat32 id_of_point;
+        sensor_msgs::ChannelFloat32 plane_id_of_point; 
         sensor_msgs::ChannelFloat32 u_of_point;
         sensor_msgs::ChannelFloat32 v_of_point;
         sensor_msgs::ChannelFloat32 velocity_x_of_point;
@@ -132,6 +133,7 @@ void callback(const sensor_msgs::ImageConstPtr &img_msg, const sensor_msgs::Imag
             auto &un_pts = trackerData[i].cur_un_pts;
             auto &cur_pts = trackerData[i].cur_pts;
             auto &ids = trackerData[i].ids;
+            auto &plane_ids = trackerData[i].plane_ids;
             auto &pts_velocity = trackerData[i].pts_velocity;
             for (unsigned int j = 0; j < ids.size(); j++)
             {
@@ -146,6 +148,7 @@ void callback(const sensor_msgs::ImageConstPtr &img_msg, const sensor_msgs::Imag
 
                     feature_points->points.push_back(p);
                     id_of_point.values.push_back(p_id * NUM_OF_CAM + i);
+                    plane_id_of_point.values.push_back(plane_ids[j]);
                     u_of_point.values.push_back(cur_pts[j].x);
                     v_of_point.values.push_back(cur_pts[j].y);
                     velocity_x_of_point.values.push_back(pts_velocity[j].x);
@@ -154,6 +157,7 @@ void callback(const sensor_msgs::ImageConstPtr &img_msg, const sensor_msgs::Imag
             }
         }
         feature_points->channels.push_back(id_of_point);
+        feature_points->channels.push_back(plane_id_of_point);
         feature_points->channels.push_back(u_of_point);
         feature_points->channels.push_back(v_of_point);
         feature_points->channels.push_back(velocity_x_of_point);
@@ -193,9 +197,9 @@ void callback(const sensor_msgs::ImageConstPtr &img_msg, const sensor_msgs::Imag
                     trackerData[i].m_camera->spaceToPlane(tmp_prev_un_pts, tmp_prev_uv);
                     cv::line(tmp_img, trackerData[i].cur_pts[j], cv::Point2f(tmp_prev_uv.x(), tmp_prev_uv.y()), cv::Scalar(255 , 0, 0), 1 , 8, 0);
                     */
-                    //char name[10];
-                    //sprintf(name, "%d", trackerData[i].ids[j]);
-                    //cv::putText(tmp_img, name, trackerData[i].cur_pts[j], cv::FONT_HERSHEY_SIMPLEX, 0.5, cv::Scalar(0, 0, 0));
+                    char name[10];
+                    sprintf(name, "%d", trackerData[i].plane_ids[j]);
+                    cv::putText(tmp_img, name, trackerData[i].cur_pts[j], cv::FONT_HERSHEY_SIMPLEX, 0.5, cv::Scalar(0, 0, 0));
                 }
             }
             //cv::imshow("vis", stereo_img);
-- 
2.17.1


From b54e7f50b03e22ccf7bf9acd91a75f7486d828c6 Mon Sep 17 00:00:00 2001
From: Karnik Ram <karnikram@gmail.com>
Date: Mon, 18 Jan 2021 18:34:33 +0530
Subject: [PATCH 23/42] process plane id up to homography computation

---
 vins_estimator/src/estimator.cpp              | 121 ++++++++++--------
 vins_estimator/src/estimator.h                |   2 +-
 vins_estimator/src/estimator_node.cpp         |  17 +--
 vins_estimator/src/feature_manager.cpp        |  11 +-
 vins_estimator/src/feature_manager.h          |  12 +-
 .../src/initial/initial_alignment.h           |   4 +-
 vins_estimator/src/initial/initial_sfm.h      |   1 +
 7 files changed, 91 insertions(+), 77 deletions(-)

diff --git a/vins_estimator/src/estimator.cpp b/vins_estimator/src/estimator.cpp
index bfa5c1e..d4b94b3 100644
--- a/vins_estimator/src/estimator.cpp
+++ b/vins_estimator/src/estimator.cpp
@@ -117,7 +117,7 @@ void Estimator::processIMU(double dt, const Vector3d &linear_acceleration, const
     gyr_0 = angular_velocity;
 }
 
-void Estimator::processImage(const map<int, vector<pair<int, Eigen::Matrix<double, 7, 1>>>> &image, const std_msgs::Header &header)
+void Estimator::processImage(const map<int, vector<pair<int, Eigen::Matrix<double, 8, 1>>>> &image, const std_msgs::Header &header)
 {
     ROS_DEBUG("new image coming ------------------------------------------");
     ROS_DEBUG("Adding feature points %lu", image.size());
@@ -137,23 +137,23 @@ void Estimator::processImage(const map<int, vector<pair<int, Eigen::Matrix<doubl
     all_image_frame.insert(make_pair(header.stamp.toSec(), imageframe));
     tmp_pre_integration = new IntegrationBase{acc_0, gyr_0, Bas[frame_count], Bgs[frame_count]};
 
-    if(ESTIMATE_EXTRINSIC == 2)
-    {
-        ROS_INFO("calibrating extrinsic param, rotation movement is needed");
-        if (frame_count != 0)
-        {
-            vector<pair<Vector3d, Vector3d>> corres = f_manager.getCorresponding(frame_count - 1, frame_count);
-            Matrix3d calib_ric;
-            if (initial_ex_rotation.CalibrationExRotation(corres, pre_integrations[frame_count]->delta_q, calib_ric))
-            {
-                ROS_WARN("initial extrinsic rotation calib success");
-                ROS_WARN_STREAM("initial extrinsic rotation: " << endl << calib_ric);
-                ric[0] = calib_ric;
-                RIC[0] = calib_ric;
-                ESTIMATE_EXTRINSIC = 1;
-            }
-        }
-    }
+    //if(ESTIMATE_EXTRINSIC == 2)
+    //{
+    //    ROS_INFO("calibrating extrinsic param, rotation movement is needed");
+    //    if (frame_count != 0)
+    //    {
+    //        vector<pair<Vector3d, Vector3d>> corres = f_manager.getCorresponding(frame_count - 1, frame_count);
+    //        Matrix3d calib_ric;
+    //        if (initial_ex_rotation.CalibrationExRotation(corres, pre_integrations[frame_count]->delta_q, calib_ric))
+    //        {
+    //            ROS_WARN("initial extrinsic rotation calib success");
+    //            ROS_WARN_STREAM("initial extrinsic rotation: " << endl << calib_ric);
+    //            ric[0] = calib_ric;
+    //            RIC[0] = calib_ric;
+    //            ESTIMATE_EXTRINSIC = 1;
+    //        }
+    //    }
+    //}
 
     if (solver_flag == INITIAL)
     {
@@ -257,6 +257,7 @@ bool Estimator::initialStructure()
         SFMFeature tmp_feature;
         tmp_feature.state = false;
         tmp_feature.id = it_per_id.feature_id;
+        tmp_feature.plane_id = it_per_id.plane_id;
         for (auto &it_per_frame : it_per_id.feature_per_frame)
         {
             imu_j++;
@@ -445,56 +446,66 @@ bool Estimator::visualInitialAlign()
     return true;
 }
 
-bool Estimator::relativePose(Matrix3d &relative_R, Vector3d &relative_T, int &l)
+//bool Estimator::relativePose(Matrix3d &relative_R, Vector3d &relative_T, int &l)
+//{
+//    // find previous frame which contians enough correspondance and parallex with newest frame
+//    for (int i = 0; i < WINDOW_SIZE; i++)
+//    {
+//        vector<pair<Vector3d, Vector3d>> corres;
+//        corres = f_manager.getCorresponding(i, WINDOW_SIZE);
+//        if (corres.size() > 20)
+//        {
+//            double sum_parallax = 0;
+//            double average_parallax;
+//            for (int j = 0; j < int(corres.size()); j++)
+//            {
+//                Vector2d pts_0(corres[j].first(0), corres[j].first(1));
+//                Vector2d pts_1(corres[j].second(0), corres[j].second(1));
+//                double parallax = (pts_0 - pts_1).norm();
+//                sum_parallax = sum_parallax + parallax;
+//            }
+//            average_parallax = 1.0 * sum_parallax / int(corres.size());
+//            if(average_parallax * 460 > 30 && m_estimator.solveRelativeRT(corres, relative_R, relative_T))
+//            {
+//                l = i;
+//                ROS_DEBUG("average_parallax %f choose l %d and newest frame to triangulate the whole structure", average_parallax * 460, l);
+//                return true;
+//            }
+//        }
+//    }
+//    return false;
+//}
+
+bool Estimator::relativeHPose(Matrix3d &relative_R, Vector3d &relative_T, Vector3d &n, int &l)
 {
-    // find previous frame which contians enough correspondance and parallex with newest frame
+    // find previous frame which contains enough correspondence and parallex with newest frame
     for (int i = 0; i < WINDOW_SIZE; i++)
     {
-        vector<pair<Vector3d, Vector3d>> corres;
-        corres = f_manager.getCorresponding(i, WINDOW_SIZE);
-        if (corres.size() > 20)
+        int lplane_id, lplane_size = 0;
+        vector<pair<Vector3d, Vector3d>> lplane_corres;
+        map<int, vector<pair<Vector3d, Vector3d>>> plane_corres = f_manager.getCorresponding(i, WINDOW_SIZE);
+        for(auto &corres : plane_corres)
         {
-            double sum_parallax = 0;
-            double average_parallax;
-            for (int j = 0; j < int(corres.size()); j++)
+            if(corres.second.size() > lplane_size)
             {
-                Vector2d pts_0(corres[j].first(0), corres[j].first(1));
-                Vector2d pts_1(corres[j].second(0), corres[j].second(1));
-                double parallax = (pts_0 - pts_1).norm();
-                sum_parallax = sum_parallax + parallax;
-            }
-            average_parallax = 1.0 * sum_parallax / int(corres.size());
-            if(average_parallax * 460 > 30 && m_estimator.solveRelativeRT(corres, relative_R, relative_T))
-            {
-                l = i;
-                ROS_DEBUG("average_parallax %f choose l %d and newest frame to triangulate the whole structure", average_parallax * 460, l);
-                return true;
+                lplane_id = corres.first;
+                lplane_size = corres.second.size();
+                lplane_corres = corres.second;
             }
         }
-    }
-    return false;
-}
-
-bool Estimator::relativeHPose(Matrix3d &relative_R, Vector3d &relative_T, Vector3d &n, int &l)
-{
-    // find previous frame which contains enough correspondence and parallex with newest frame
-    for (int i = 0; i < WINDOW_SIZE; i++)
-    {
-        vector<pair<Vector3d, Vector3d>> corres;
-        corres = f_manager.getCorresponding(i, WINDOW_SIZE);
-        if (corres.size() > 20)
+        if (lplane_size > 20)
         {
             double sum_parallax = 0;
             double average_parallax;
-            for (int j = 0; j < int(corres.size()); j++)
+            for (int j = 0; j < int(lplane_corres.size()); j++)
             {
-                Vector2d pts_0(corres[j].first(0), corres[j].first(1));
-                Vector2d pts_1(corres[j].second(0), corres[j].second(1));
+                Vector2d pts_0(lplane_corres[j].first(0), lplane_corres[j].first(1));
+                Vector2d pts_1(lplane_corres[j].second(0), lplane_corres[j].second(1));
                 double parallax = (pts_0 - pts_1).norm();
                 sum_parallax = sum_parallax + parallax;
-
             }
-            average_parallax = 1.0 * sum_parallax / int(corres.size());
+
+            average_parallax = 1.0 * sum_parallax / int(lplane_corres.size());
 
             Matrix4d TrIC = Matrix4d::Identity(); 
             TrIC.block(0,0,3,3) = ric[0];
@@ -505,7 +516,7 @@ bool Estimator::relativeHPose(Matrix3d &relative_R, Vector3d &relative_T, Vector
             for(int k = WINDOW_SIZE - 1; k > i; k--)
                 R_imu = R_imu * (pre_integrations[k]->delta_q).toRotationMatrix();
 
-            if(average_parallax * 460 > 30 && m_estimator.solveRelativeHRT(corres, R_imu, TrIC, relative_R, relative_T, n))
+            if(average_parallax * 460 > 30 && m_estimator.solveRelativeHRT(lplane_corres, R_imu, TrIC, relative_R, relative_T, n))
             {
                 l = i;
                 ROS_DEBUG("average_parallax %f choose l %d and newest frame to triangulate the whole structure", average_parallax * 460, l);
diff --git a/vins_estimator/src/estimator.h b/vins_estimator/src/estimator.h
index adad3cd..e109500 100644
--- a/vins_estimator/src/estimator.h
+++ b/vins_estimator/src/estimator.h
@@ -33,7 +33,7 @@ class Estimator
 
     // interface
     void processIMU(double t, const Vector3d &linear_acceleration, const Vector3d &angular_velocity);
-    void processImage(const map<int, vector<pair<int, Eigen::Matrix<double, 7, 1>>>> &image, const std_msgs::Header &header);
+    void processImage(const map<int, vector<pair<int, Eigen::Matrix<double, 8, 1>>>> &image, const std_msgs::Header &header);
     void setReloFrame(double _frame_stamp, int _frame_index, vector<Vector3d> &_match_points, Vector3d _relo_t, Matrix3d _relo_r);
 
     // internal
diff --git a/vins_estimator/src/estimator_node.cpp b/vins_estimator/src/estimator_node.cpp
index 1297936..d20f9eb 100644
--- a/vins_estimator/src/estimator_node.cpp
+++ b/vins_estimator/src/estimator_node.cpp
@@ -293,23 +293,24 @@ void process()
             ROS_DEBUG("processing vision data with stamp %f \n", img_msg->header.stamp.toSec());
 
             TicToc t_s;
-            map<int, vector<pair<int, Eigen::Matrix<double, 7, 1>>>> image;
+            map<int, vector<pair<int, Eigen::Matrix<double, 8, 1>>>> image;
             for (unsigned int i = 0; i < img_msg->points.size(); i++)
             {
                 int v = img_msg->channels[0].values[i] + 0.5;
                 int feature_id = v / NUM_OF_CAM;
                 int camera_id = v % NUM_OF_CAM;
+                int plane_id = img_msg->channels[1].values[i];
                 double x = img_msg->points[i].x;
                 double y = img_msg->points[i].y;
                 double z = img_msg->points[i].z;
-                double p_u = img_msg->channels[1].values[i];
-                double p_v = img_msg->channels[2].values[i];
-                double velocity_x = img_msg->channels[3].values[i];
-                double velocity_y = img_msg->channels[4].values[i];
+                double p_u = img_msg->channels[2].values[i];
+                double p_v = img_msg->channels[3].values[i];
+                double velocity_x = img_msg->channels[4].values[i];
+                double velocity_y = img_msg->channels[5].values[i];
                 ROS_ASSERT(z == 1);
-                Eigen::Matrix<double, 7, 1> xyz_uv_velocity;
-                xyz_uv_velocity << x, y, z, p_u, p_v, velocity_x, velocity_y;
-                image[feature_id].emplace_back(camera_id,  xyz_uv_velocity);
+                Eigen::Matrix<double, 8, 1> xyz_uv_velocity_pid;
+                xyz_uv_velocity_pid << x, y, z, p_u, p_v, velocity_x, velocity_y, plane_id;
+                image[feature_id].emplace_back(camera_id,  xyz_uv_velocity_pid);
             }
             estimator.processImage(image, img_msg->header);
 
diff --git a/vins_estimator/src/feature_manager.cpp b/vins_estimator/src/feature_manager.cpp
index 7d5aed9..17f75b9 100644
--- a/vins_estimator/src/feature_manager.cpp
+++ b/vins_estimator/src/feature_manager.cpp
@@ -42,7 +42,7 @@ int FeatureManager::getFeatureCount()
 }
 
 
-bool FeatureManager::addFeatureCheckParallax(int frame_count, const map<int, vector<pair<int, Eigen::Matrix<double, 7, 1>>>> &image, double td)
+bool FeatureManager::addFeatureCheckParallax(int frame_count, const map<int, vector<pair<int, Eigen::Matrix<double, 8, 1>>>> &image, double td)
 {
     ROS_DEBUG("input feature: %d", (int)image.size());
     ROS_DEBUG("num of feature: %d", getFeatureCount());
@@ -61,7 +61,8 @@ bool FeatureManager::addFeatureCheckParallax(int frame_count, const map<int, vec
 
         if (it == feature.end())
         {
-            feature.push_back(FeaturePerId(feature_id, frame_count));
+            int plane_id = id_pts.second[0].second(7);
+            feature.push_back(FeaturePerId(feature_id, plane_id, frame_count));
             feature.back().feature_per_frame.push_back(f_per_fra);
         }
         else if (it->feature_id == feature_id)
@@ -117,9 +118,9 @@ void FeatureManager::debugShow()
     }
 }
 
-vector<pair<Vector3d, Vector3d>> FeatureManager::getCorresponding(int frame_count_l, int frame_count_r)
+map<int, vector<pair<Vector3d, Vector3d>>> FeatureManager::getCorresponding(int frame_count_l, int frame_count_r)
 {
-    vector<pair<Vector3d, Vector3d>> corres;
+    map<int, vector<pair<Vector3d, Vector3d>>> corres;
     for (auto &it : feature)
     {
         if (it.start_frame <= frame_count_l && it.endFrame() >= frame_count_r)
@@ -132,7 +133,7 @@ vector<pair<Vector3d, Vector3d>> FeatureManager::getCorresponding(int frame_coun
 
             b = it.feature_per_frame[idx_r].point;
             
-            corres.push_back(make_pair(a, b));
+            corres[it.plane_id].push_back(make_pair(a, b));
         }
     }
     return corres;
diff --git a/vins_estimator/src/feature_manager.h b/vins_estimator/src/feature_manager.h
index 4e5d3ce..ca94634 100644
--- a/vins_estimator/src/feature_manager.h
+++ b/vins_estimator/src/feature_manager.h
@@ -18,7 +18,7 @@ using namespace Eigen;
 class FeaturePerFrame
 {
   public:
-    FeaturePerFrame(const Eigen::Matrix<double, 7, 1> &_point, double td)
+    FeaturePerFrame(const Eigen::Matrix<double, 8, 1> &_point, double td)
     {
         point.x() = _point(0);
         point.y() = _point(1);
@@ -44,7 +44,7 @@ class FeaturePerFrame
 class FeaturePerId
 {
   public:
-    const int feature_id;
+    const int feature_id, plane_id;
     int start_frame;
     vector<FeaturePerFrame> feature_per_frame;
 
@@ -56,8 +56,8 @@ class FeaturePerId
 
     Vector3d gt_p;
 
-    FeaturePerId(int _feature_id, int _start_frame)
-        : feature_id(_feature_id), start_frame(_start_frame),
+    FeaturePerId(int _feature_id, int _plane_id, int _start_frame)
+        : feature_id(_feature_id), plane_id(_plane_id), start_frame(_start_frame),
           used_num(0), estimated_depth(-1.0), solve_flag(0)
     {
     }
@@ -76,9 +76,9 @@ class FeatureManager
 
     int getFeatureCount();
 
-    bool addFeatureCheckParallax(int frame_count, const map<int, vector<pair<int, Eigen::Matrix<double, 7, 1>>>> &image, double td);
+    bool addFeatureCheckParallax(int frame_count, const map<int, vector<pair<int, Eigen::Matrix<double, 8, 1>>>> &image, double td);
     void debugShow();
-    vector<pair<Vector3d, Vector3d>> getCorresponding(int frame_count_l, int frame_count_r);
+    map<int, vector<pair<Vector3d, Vector3d>>> getCorresponding(int frame_count_l, int frame_count_r);
 
     //void updateDepth(const VectorXd &x);
     void setDepth(const VectorXd &x);
diff --git a/vins_estimator/src/initial/initial_alignment.h b/vins_estimator/src/initial/initial_alignment.h
index 49bc466..392337e 100644
--- a/vins_estimator/src/initial/initial_alignment.h
+++ b/vins_estimator/src/initial/initial_alignment.h
@@ -14,11 +14,11 @@ class ImageFrame
 {
     public:
         ImageFrame(){};
-        ImageFrame(const map<int, vector<pair<int, Eigen::Matrix<double, 7, 1>>>>& _points, double _t):t{_t},is_key_frame{false}
+        ImageFrame(const map<int, vector<pair<int, Eigen::Matrix<double, 8, 1>>>>& _points, double _t):t{_t},is_key_frame{false}
         {
             points = _points;
         };
-        map<int, vector<pair<int, Eigen::Matrix<double, 7, 1>> > > points;
+        map<int, vector<pair<int, Eigen::Matrix<double, 8, 1>> > > points;
         double t;
         Matrix3d R;
         Vector3d T;
diff --git a/vins_estimator/src/initial/initial_sfm.h b/vins_estimator/src/initial/initial_sfm.h
index a070742..3c51e44 100644
--- a/vins_estimator/src/initial/initial_sfm.h
+++ b/vins_estimator/src/initial/initial_sfm.h
@@ -17,6 +17,7 @@ struct SFMFeature
 {
     bool state;
     int id;
+	int plane_id;
     vector<pair<int,Vector2d>> observation;
     double position[3];
     double image[3]; // u v 1
-- 
2.17.1


From f953992bf0a51d466f28bcd0e78e155e8063560d Mon Sep 17 00:00:00 2001
From: Karnik Ram <karnikram@gmail.com>
Date: Wed, 20 Jan 2021 14:53:49 +0530
Subject: [PATCH 24/42] Compute homographies for each plane

---
 vins_estimator/src/estimator.cpp | 61 +++++++++++++++++++++++---------
 vins_estimator/src/estimator.h   |  2 +-
 2 files changed, 45 insertions(+), 18 deletions(-)

diff --git a/vins_estimator/src/estimator.cpp b/vins_estimator/src/estimator.cpp
index d4b94b3..be5bc42 100644
--- a/vins_estimator/src/estimator.cpp
+++ b/vins_estimator/src/estimator.cpp
@@ -246,6 +246,19 @@ bool Estimator::initialStructure()
             //return false;
         }
     }
+    
+    // Bootstrap SfM
+    map<int, Matrix3d> relative_R;
+    map<int, Vector3d> relative_T;
+    map<int, Vector3d> n;
+    int l, lplane_id;
+
+    if (!relativeHPose(relative_R, relative_T, n, l, lplane_id))
+    {
+        ROS_INFO("Not enough features or parallax; Move device around");
+        return false;
+    }
+
     // global sfm
     Quaterniond Q[frame_count + 1];
     Vector3d T[frame_count + 1];
@@ -253,6 +266,10 @@ bool Estimator::initialStructure()
     vector<SFMFeature> sfm_f;
     for (auto &it_per_id : f_manager.feature)
     {
+        // Consider only features from largest plne
+        if(it_per_id.plane_id != lplane_id)
+            continue;
+
         int imu_j = it_per_id.start_frame - 1;
         SFMFeature tmp_feature;
         tmp_feature.state = false;
@@ -265,19 +282,11 @@ bool Estimator::initialStructure()
             tmp_feature.observation.push_back(make_pair(imu_j, Eigen::Vector2d{pts_j.x(), pts_j.y()}));
         }
         sfm_f.push_back(tmp_feature);
-    } 
-    Matrix3d relative_R;
-    Vector3d relative_T;
-    Vector3d n;
-    int l;
-    if (!relativeHPose(relative_R, relative_T, n, l))
-    {
-        ROS_INFO("Not enough features or parallax; Move device around");
-        return false;
     }
+
     GlobalSFM sfm;
     if(!sfm.constructH(frame_count + 1, Q, T, l,
-              relative_R, relative_T, n,
+              relative_R[lplane_id], relative_T[lplane_id], n[lplane_id],
               sfm_f, sfm_tracked_points))
     {
         ROS_DEBUG("global SFM failed!");
@@ -285,9 +294,9 @@ bool Estimator::initialStructure()
         return false;
     }
     para_N[0] = 0;
-    para_N[1] = n[0];
-    para_N[2] = n[1];
-    para_N[3] = n[2];
+    para_N[1] = n[lplane_id][0];
+    para_N[2] = n[lplane_id][1];
+    para_N[3] = n[lplane_id][2];
 
     //solve pnp for all frame
     map<double, ImageFrame>::iterator frame_it;
@@ -476,12 +485,12 @@ bool Estimator::visualInitialAlign()
 //    return false;
 //}
 
-bool Estimator::relativeHPose(Matrix3d &relative_R, Vector3d &relative_T, Vector3d &n, int &l)
+bool Estimator::relativeHPose(map<int, Matrix3d> &relative_R, map<int, Vector3d> &relative_t, map<int, Vector3d> &n, int &l, int &lplane_id)
 {
     // find previous frame which contains enough correspondence and parallex with newest frame
     for (int i = 0; i < WINDOW_SIZE; i++)
     {
-        int lplane_id, lplane_size = 0;
+        int lplane_size = 0;
         vector<pair<Vector3d, Vector3d>> lplane_corres;
         map<int, vector<pair<Vector3d, Vector3d>>> plane_corres = f_manager.getCorresponding(i, WINDOW_SIZE);
         for(auto &corres : plane_corres)
@@ -507,7 +516,7 @@ bool Estimator::relativeHPose(Matrix3d &relative_R, Vector3d &relative_T, Vector
 
             average_parallax = 1.0 * sum_parallax / int(lplane_corres.size());
 
-            Matrix4d TrIC = Matrix4d::Identity(); 
+            Matrix4d TrIC = Matrix4d::Identity();
             TrIC.block(0,0,3,3) = ric[0];
             TrIC.block(0,3,3,1) = tic[0];
 
@@ -516,10 +525,28 @@ bool Estimator::relativeHPose(Matrix3d &relative_R, Vector3d &relative_T, Vector
             for(int k = WINDOW_SIZE - 1; k > i; k--)
                 R_imu = R_imu * (pre_integrations[k]->delta_q).toRotationMatrix();
 
-            if(average_parallax * 460 > 30 && m_estimator.solveRelativeHRT(lplane_corres, R_imu, TrIC, relative_R, relative_T, n))
+            Eigen::Matrix3d est_R;
+            Eigen::Vector3d est_t, est_n;
+            if(average_parallax * 460 > 30 && m_estimator.solveRelativeHRT(lplane_corres, R_imu, TrIC, est_R, est_t, est_n))
             {
                 l = i;
                 ROS_DEBUG("average_parallax %f choose l %d and newest frame to triangulate the whole structure", average_parallax * 460, l);
+                relative_R[lplane_id] = est_R;
+                relative_t[lplane_id] = est_t;
+                n[lplane_id] = est_n;
+
+                for(auto &corres : plane_corres)
+                {
+                    if(corres.first == lplane_id)
+                        continue;
+                    
+                    if(m_estimator.solveRelativeHRT(corres.second, R_imu, TrIC, est_R, est_t, est_n))
+                    {
+                        relative_R[corres.first] = est_R;
+                        relative_t[corres.first] = est_t;
+                        n[corres.first] = est_n;
+                    }
+                }
                 return true;
             }
         }
diff --git a/vins_estimator/src/estimator.h b/vins_estimator/src/estimator.h
index e109500..8efe106 100644
--- a/vins_estimator/src/estimator.h
+++ b/vins_estimator/src/estimator.h
@@ -41,7 +41,7 @@ class Estimator
     bool initialStructure();
     bool visualInitialAlign();
     bool relativePose(Matrix3d &relative_R, Vector3d &relative_T, int &l);
-    bool relativeHPose(Matrix3d &relative_R, Vector3d &relative_T, Vector3d &n, int &l);
+    bool relativeHPose(map<int, Matrix3d> &relative_R, map<int, Vector3d> &relative_T, map<int, Vector3d> &n, int &l, int &lplane_id);
     void slideWindow();
     void solveOdometry();
     void slideWindowNew();
-- 
2.17.1


From 1ae6a50d3a5dbd1b9d193a7dfe00be2adadf987c Mon Sep 17 00:00:00 2001
From: Karnik Ram <karnikram@gmail.com>
Date: Thu, 21 Jan 2021 19:28:53 +0530
Subject: [PATCH 25/42] Use individual planes inside estimator

---
 vins_estimator/src/estimator.cpp             | 46 ++++++++++++++------
 vins_estimator/src/estimator.h               |  8 ++--
 vins_estimator/src/feature_manager.cpp       |  1 +
 vins_estimator/src/utility/visualization.cpp |  1 +
 4 files changed, 38 insertions(+), 18 deletions(-)

diff --git a/vins_estimator/src/estimator.cpp b/vins_estimator/src/estimator.cpp
index be5bc42..74261f9 100644
--- a/vins_estimator/src/estimator.cpp
+++ b/vins_estimator/src/estimator.cpp
@@ -176,7 +176,6 @@ void Estimator::processImage(const map<int, vector<pair<int, Eigen::Matrix<doubl
                 last_P = Ps[WINDOW_SIZE];
                 last_R0 = Rs[0];
                 last_P0 = Ps[0];
-                
             }
             else
                 slideWindow();
@@ -215,6 +214,7 @@ void Estimator::processImage(const map<int, vector<pair<int, Eigen::Matrix<doubl
         last_P0 = Ps[0];
     }
 }
+
 bool Estimator::initialStructure()
 {
     TicToc t_sfm;
@@ -251,7 +251,7 @@ bool Estimator::initialStructure()
     map<int, Matrix3d> relative_R;
     map<int, Vector3d> relative_T;
     map<int, Vector3d> n;
-    int l, lplane_id;
+    int l;
 
     if (!relativeHPose(relative_R, relative_T, n, l, lplane_id))
     {
@@ -293,10 +293,12 @@ bool Estimator::initialStructure()
         marginalization_flag = MARGIN_OLD;
         return false;
     }
-    para_N[0] = 0;
-    para_N[1] = n[lplane_id][0];
-    para_N[2] = n[lplane_id][1];
-    para_N[3] = n[lplane_id][2];
+
+    // Save estimated normal variables
+    for(auto &est_n : n)
+    {
+        para_N[est_n.first] = {0, est_n.second(0), est_n.second(1), est_n.second(2)};
+    }
 
     //solve pnp for all frame
     map<double, ImageFrame>::iterator frame_it;
@@ -366,17 +368,16 @@ bool Estimator::initialStructure()
         frame_it->second.R = R_pnp * RIC[0].transpose();
         frame_it->second.T = T_pnp;
     }
-    if (visualInitialAlign())
+    if (visualInitialAlign(relative_T, T[frame_count]))
         return true;
     else
     {
         ROS_INFO("misalign visual structure with IMU");
         return false;
     }
-
 }
 
-bool Estimator::visualInitialAlign()
+bool Estimator::visualInitialAlign(map<int, Eigen::Vector3d> &relative_T, Eigen::Vector3d &lt)
 {
     TicToc t_g;
     VectorXd x;
@@ -412,7 +413,7 @@ bool Estimator::visualInitialAlign()
     f_manager.triangulate(Ps, &(TIC_TMP[0]), &(RIC[0]));
 
     s = (x.tail<1>())(0);
-    para_d[0] = s;
+
     for (int i = 0; i <= WINDOW_SIZE; i++)
     {
         pre_integrations[i]->repropagate(Vector3d::Zero(), Bgs[i]);
@@ -434,9 +435,19 @@ bool Estimator::visualInitialAlign()
         it_per_id.used_num = it_per_id.feature_per_frame.size();
         if (!(it_per_id.used_num >= 2 && it_per_id.start_frame < WINDOW_SIZE - 2))
             continue;
+
         it_per_id.estimated_depth *= s;
     }
 
+    //estimate plane d variables
+    for(auto &t : relative_T)
+    {
+        if(t.first == lplane_id)
+            para_d[lplane_id] = {s};
+        else
+           para_d[t.first] = {s*lt.norm()/t.second.norm()}; 
+    } 
+
     Matrix3d R0 = Utility::g2R(g);
     double yaw = Utility::R2ypr(R0 * Rs[0]).x();
     R0 = Utility::ypr2R(Eigen::Vector3d{-yaw, 0, 0}) * R0;
@@ -764,8 +775,11 @@ void Estimator::optimization()
         problem.AddParameterBlock(para_SpeedBias[i], SIZE_SPEEDBIAS);
     }
 
-    ceres::LocalParameterization *local_n_parameterization = new ceres::QuaternionParameterization();
-    problem.AddParameterBlock(para_N, 4, local_n_parameterization);
+    for(auto &N : para_N)
+    {
+        ceres::LocalParameterization *local_n_parameterization = new ceres::QuaternionParameterization();
+        problem.AddParameterBlock(N.second.data(), 4, local_n_parameterization);
+    }
 
     for (int i = 0; i < NUM_OF_CAM; i++)
     {
@@ -811,12 +825,16 @@ void Estimator::optimization()
         it_per_id.used_num = it_per_id.feature_per_frame.size();
         if (!(it_per_id.used_num >= 2 && it_per_id.start_frame < WINDOW_SIZE - 2))
             continue;
- 
+
         ++feature_index;
 
         int imu_i = it_per_id.start_frame, imu_j = imu_i - 1;
         
         Vector3d pts_i = it_per_id.feature_per_frame[0].point;
+        int pid = it_per_id.plane_id;
+
+        if(!(para_N.count(pid) > 0 && para_d.count(pid) > 0))
+            continue;
 
         for (auto &it_per_frame : it_per_id.feature_per_frame)
         {
@@ -850,7 +868,7 @@ void Estimator::optimization()
                 problem.AddResidualBlock(f, loss_function, para_Pose[imu_i], para_Pose[imu_j], para_Ex_Pose[0], para_Feature[feature_index]);
 
                 ceres::CostFunction *h_cost_function = HomographyFactor::Create(pts_i, pts_j);
-                problem.AddResidualBlock(h_cost_function, loss_function, para_Pose[imu_i], para_Pose[imu_j], para_N, para_d, para_Ex_Pose[0]);
+                problem.AddResidualBlock(h_cost_function, loss_function, para_Pose[imu_i], para_Pose[imu_j], para_N[pid].data(), para_d[pid].data(), para_Ex_Pose[0]);
             }
             f_m_cnt++;
         }
diff --git a/vins_estimator/src/estimator.h b/vins_estimator/src/estimator.h
index 8efe106..b7c32db 100644
--- a/vins_estimator/src/estimator.h
+++ b/vins_estimator/src/estimator.h
@@ -39,7 +39,7 @@ class Estimator
     // internal
     void clearState();
     bool initialStructure();
-    bool visualInitialAlign();
+    bool visualInitialAlign(map<int,Eigen::Vector3d> &relative_T, Eigen::Vector3d &lt);
     bool relativePose(Matrix3d &relative_R, Vector3d &relative_T, int &l);
     bool relativeHPose(map<int, Matrix3d> &relative_R, map<int, Vector3d> &relative_T, map<int, Vector3d> &n, int &l, int &lplane_id);
     void slideWindow();
@@ -80,6 +80,7 @@ class Estimator
     Vector3d Bgs[(WINDOW_SIZE + 1)];
     double td;
     double s;
+    int lplane_id;
 
     Matrix3d back_R0, last_R, last_R0;
     Vector3d back_P0, last_P, last_P0;
@@ -108,7 +109,6 @@ class Estimator
     vector<Vector3d> key_poses;
     double initial_timestamp;
 
-
     double para_Pose[WINDOW_SIZE + 1][SIZE_POSE];
     double para_SpeedBias[WINDOW_SIZE + 1][SIZE_SPEEDBIAS];
     double para_Feature[NUM_OF_F][SIZE_FEATURE];
@@ -116,8 +116,8 @@ class Estimator
     double para_Retrive_Pose[SIZE_POSE];
     double para_Td[1][1];
     double para_Tr[1][1];
-    double para_N[4];
-    double para_d[1];
+    map<int, array<double,4>> para_N;
+    map<int, array<double,1>> para_d;
 
     int loop_window_index;
 
diff --git a/vins_estimator/src/feature_manager.cpp b/vins_estimator/src/feature_manager.cpp
index 17f75b9..45f14b8 100644
--- a/vins_estimator/src/feature_manager.cpp
+++ b/vins_estimator/src/feature_manager.cpp
@@ -210,6 +210,7 @@ void FeatureManager::triangulate(Vector3d Ps[], Vector3d tic[], Matrix3d ric[])
 
         if (it_per_id.estimated_depth > 0)
             continue;
+
         int imu_i = it_per_id.start_frame, imu_j = imu_i - 1;
 
         ROS_ASSERT(NUM_OF_CAM == 1);
diff --git a/vins_estimator/src/utility/visualization.cpp b/vins_estimator/src/utility/visualization.cpp
index 167e913..eb87e13 100644
--- a/vins_estimator/src/utility/visualization.cpp
+++ b/vins_estimator/src/utility/visualization.cpp
@@ -252,6 +252,7 @@ void pubPointCloud(const Estimator &estimator, const std_msgs::Header &header)
             continue;
         if (it_per_id.start_frame > WINDOW_SIZE * 3.0 / 4.0 || it_per_id.solve_flag != 1)
             continue;
+
         int imu_i = it_per_id.start_frame;
         Vector3d pts_i = it_per_id.feature_per_frame[0].point * it_per_id.estimated_depth;
         Vector3d w_pts_i = estimator.Rs[imu_i] * (estimator.ric[0] * pts_i + estimator.tic[0]) + estimator.Ps[imu_i];
-- 
2.17.1


From 29ecb88038821e1d73c60136485cb1435ac38e06 Mon Sep 17 00:00:00 2001
From: Karnik Ram <karnikram@gmail.com>
Date: Fri, 22 Jan 2021 13:03:28 +0530
Subject: [PATCH 26/42] Initialize new planes

---
 vins_estimator/src/estimator.cpp       | 61 +++++++++++++++++++++++++-
 vins_estimator/src/estimator.h         |  3 +-
 vins_estimator/src/feature_manager.cpp | 25 +++++++++++
 vins_estimator/src/feature_manager.h   |  2 +
 4 files changed, 89 insertions(+), 2 deletions(-)

diff --git a/vins_estimator/src/estimator.cpp b/vins_estimator/src/estimator.cpp
index 74261f9..eee27b5 100644
--- a/vins_estimator/src/estimator.cpp
+++ b/vins_estimator/src/estimator.cpp
@@ -186,6 +186,7 @@ void Estimator::processImage(const map<int, vector<pair<int, Eigen::Matrix<doubl
     else
     {
         TicToc t_solve;
+        initializePlanes();
         solveOdometry();
         ROS_DEBUG("solver costs: %fms", t_solve.toc());
 
@@ -513,6 +514,7 @@ bool Estimator::relativeHPose(map<int, Matrix3d> &relative_R, map<int, Vector3d>
                 lplane_corres = corres.second;
             }
         }
+
         if (lplane_size > 20)
         {
             double sum_parallax = 0;
@@ -550,12 +552,13 @@ bool Estimator::relativeHPose(map<int, Matrix3d> &relative_R, map<int, Vector3d>
                 {
                     if(corres.first == lplane_id)
                         continue;
-                    
+
                     if(m_estimator.solveRelativeHRT(corres.second, R_imu, TrIC, est_R, est_t, est_n))
                     {
                         relative_R[corres.first] = est_R;
                         relative_t[corres.first] = est_t;
                         n[corres.first] = est_n;
+                        ROS_INFO("Initialized plane %d features", corres.first);
                     }
                 }
                 return true;
@@ -565,6 +568,62 @@ bool Estimator::relativeHPose(map<int, Matrix3d> &relative_R, map<int, Vector3d>
     return false;
 }
 
+void Estimator::initializePlanes()
+{
+    // check for new plane ids
+    for(auto &plane_id : f_manager.plane_ids)
+    {
+        if(para_N.count(plane_id) > 0)
+            continue;
+        else
+        {
+            for(int i = 0; i < WINDOW_SIZE - 1; i++)
+            {
+                vector<pair<Vector3d, Vector3d>> corres = f_manager.getCorrespondingByPlane(
+                    i, WINDOW_SIZE-1, plane_id);
+
+                if(corres.size() > 20)
+                {
+                    double sum_parallax = 0;
+                    double average_parallax;
+                    for (int j = 0; j < int(corres.size()); j++)
+                    {
+                        Vector2d pts_0(corres[j].first(0), corres[j].first(1));
+                        Vector2d pts_1(corres[j].second(0), corres[j].second(1));
+                        double parallax = (pts_0 - pts_1).norm();
+                        sum_parallax = sum_parallax + parallax;
+                    }
+
+                    average_parallax = 1.0 * sum_parallax / int(corres.size());
+
+                    Matrix4d TrIC = Matrix4d::Identity();
+                    TrIC.block(0,0,3,3) = ric[0];
+                    TrIC.block(0,3,3,1) = tic[0];
+
+                    //compute corresponding preintegrated rotation
+                    Matrix3d R_imu = Matrix3d::Identity();
+                    for(int k = WINDOW_SIZE - 2; k > i; k--)
+                        R_imu = R_imu * (pre_integrations[k]->delta_q).toRotationMatrix();
+
+                    Eigen::Matrix3d est_R;
+                    Eigen::Vector3d est_t, est_n, vi_t;
+                    if(average_parallax * 460 > 30 && m_estimator.solveRelativeHRT(corres, R_imu, TrIC, est_R, est_t, est_n))
+                    {
+                        // Transform est_n to global frame
+                        est_n = Rs[i] * est_n;
+                        para_N[plane_id] = {0, est_n(0), est_n(1), est_n(2)};
+
+                        // Estimate plane d using known metric t from vio 
+                        vi_t = Rs[i].transpose() * (Ps[WINDOW_SIZE - 1] - Ps[i]);
+                        para_d[plane_id] = {(1.0*vi_t.norm()/est_t.norm())};
+                        ROS_INFO("Initialized plane %d features", plane_id);
+                    }
+                }
+            }
+        }
+    }
+}
+
 void Estimator::solveOdometry()
 {
     if (frame_count < WINDOW_SIZE)
diff --git a/vins_estimator/src/estimator.h b/vins_estimator/src/estimator.h
index b7c32db..7c54363 100644
--- a/vins_estimator/src/estimator.h
+++ b/vins_estimator/src/estimator.h
@@ -42,6 +42,7 @@ class Estimator
     bool visualInitialAlign(map<int,Eigen::Vector3d> &relative_T, Eigen::Vector3d &lt);
     bool relativePose(Matrix3d &relative_R, Vector3d &relative_T, int &l);
     bool relativeHPose(map<int, Matrix3d> &relative_R, map<int, Vector3d> &relative_T, map<int, Vector3d> &n, int &l, int &lplane_id);
+    void initializePlanes();
     void slideWindow();
     void solveOdometry();
     void slideWindowNew();
@@ -127,7 +128,7 @@ class Estimator
     map<double, ImageFrame> all_image_frame;
     IntegrationBase *tmp_pre_integration;
 
-    //relocalization variable
+    //relocalization variables
     bool relocalization_info;
     double relo_frame_stamp;
     double relo_frame_index;
diff --git a/vins_estimator/src/feature_manager.cpp b/vins_estimator/src/feature_manager.cpp
index 45f14b8..64828ee 100644
--- a/vins_estimator/src/feature_manager.cpp
+++ b/vins_estimator/src/feature_manager.cpp
@@ -62,6 +62,7 @@ bool FeatureManager::addFeatureCheckParallax(int frame_count, const map<int, vec
         if (it == feature.end())
         {
             int plane_id = id_pts.second[0].second(7);
+            plane_ids.insert(plane_id);
             feature.push_back(FeaturePerId(feature_id, plane_id, frame_count));
             feature.back().feature_per_frame.push_back(f_per_fra);
         }
@@ -139,6 +140,30 @@ map<int, vector<pair<Vector3d, Vector3d>>> FeatureManager::getCorresponding(int
     return corres;
 }
 
+vector<pair<Vector3d, Vector3d>> FeatureManager::getCorrespondingByPlane(int frame_count_l, int frame_count_r, int plane_id)
+{
+    vector<pair<Vector3d, Vector3d>> corres;
+    for (auto &it : feature)
+    {
+        if(it.plane_id != plane_id)
+            continue;
+
+        if (it.start_frame <= frame_count_l && it.endFrame() >= frame_count_r)
+        {
+            Vector3d a = Vector3d::Zero(), b = Vector3d::Zero();
+            int idx_l = frame_count_l - it.start_frame;
+            int idx_r = frame_count_r - it.start_frame;
+
+            a = it.feature_per_frame[idx_l].point;
+
+            b = it.feature_per_frame[idx_r].point;
+            
+            corres.push_back(make_pair(a, b));
+        }
+    }
+    return corres;
+}
+
 void FeatureManager::setDepth(const VectorXd &x)
 {
     int feature_index = -1;
diff --git a/vins_estimator/src/feature_manager.h b/vins_estimator/src/feature_manager.h
index ca94634..a7f46fc 100644
--- a/vins_estimator/src/feature_manager.h
+++ b/vins_estimator/src/feature_manager.h
@@ -79,6 +79,8 @@ class FeatureManager
     bool addFeatureCheckParallax(int frame_count, const map<int, vector<pair<int, Eigen::Matrix<double, 8, 1>>>> &image, double td);
     void debugShow();
     map<int, vector<pair<Vector3d, Vector3d>>> getCorresponding(int frame_count_l, int frame_count_r);
+    vector<pair<Vector3d, Vector3d>> getCorrespondingByPlane(int frame_count_l, int frame_count_r, int plane_id);
+    set<int> plane_ids;
 
     //void updateDepth(const VectorXd &x);
     void setDepth(const VectorXd &x);
-- 
2.17.1


From 41b63dbda66a5cef24d407c3ae2952ff8d876bca Mon Sep 17 00:00:00 2001
From: Karnik Ram <karnikram@gmail.com>
Date: Fri, 22 Jan 2021 19:33:33 +0530
Subject: [PATCH 27/42] Call add points only when there are new points

---
 feature_tracker/src/feature_tracker.cpp      | 10 +++++-----
 feature_tracker/src/feature_tracker_node.cpp |  2 +-
 2 files changed, 6 insertions(+), 6 deletions(-)

diff --git a/feature_tracker/src/feature_tracker.cpp b/feature_tracker/src/feature_tracker.cpp
index 0de4262..c42426c 100644
--- a/feature_tracker/src/feature_tracker.cpp
+++ b/feature_tracker/src/feature_tracker.cpp
@@ -183,15 +183,15 @@ void FeatureTracker::readImage(const cv::Mat &_img, const cv::Mat &_mask, double
             if (mask.size() != forw_img.size())
                 cout << "wrong size " << endl;
             cv::goodFeaturesToTrack(forw_img, n_pts, MAX_CNT - forw_pts.size(), 0.01, MIN_DIST, mask);
+            ROS_DEBUG("add feature begins");
+            TicToc t_a;
+            addPoints(_mask);
+            ROS_DEBUG("selectFeature costs: %fms", t_a.toc());
         }
+
         else
             n_pts.clear();
         ROS_DEBUG("detect feature costs: %fms", t_t.toc());
-
-        ROS_DEBUG("add feature begins");
-        TicToc t_a;
-        addPoints(_mask);
-        ROS_DEBUG("selectFeature costs: %fms", t_a.toc());
     }
     prev_img = cur_img;
     prev_pts = cur_pts;
diff --git a/feature_tracker/src/feature_tracker_node.cpp b/feature_tracker/src/feature_tracker_node.cpp
index b9de94a..ba64fed 100644
--- a/feature_tracker/src/feature_tracker_node.cpp
+++ b/feature_tracker/src/feature_tracker_node.cpp
@@ -86,7 +86,7 @@ void callback(const sensor_msgs::ImageConstPtr &img_msg, const sensor_msgs::Imag
     {
         ROS_DEBUG("processing camera %d", i);
         if (i != 1 || !STEREO_TRACK)
-            trackerData[i].readImage(ptr->image.rowRange(ROW * i, ROW * (i + 1)), mask_ptr->image.rowRange(ROW*i,ROW*(i+1)), img_msg->header.stamp.toSec());
+            trackerData[i].readImage(ptr->image.rowRange(ROW * i, ROW * (i + 1)), mask_ptr->image.rowRange(ROW * i,ROW * (i + 1)), img_msg->header.stamp.toSec());
         else
         {
             if (EQUALIZE)
-- 
2.17.1


From b8a80ed0a1ce5187c6eaafc514f0f75b6a724d11 Mon Sep 17 00:00:00 2001
From: Karnik Ram <karnikram@gmail.com>
Date: Fri, 22 Jan 2021 20:35:06 +0530
Subject: [PATCH 28/42] Revert to F rejection

---
 feature_tracker/src/feature_tracker.cpp | 6 +++---
 1 file changed, 3 insertions(+), 3 deletions(-)

diff --git a/feature_tracker/src/feature_tracker.cpp b/feature_tracker/src/feature_tracker.cpp
index c42426c..6548c36 100644
--- a/feature_tracker/src/feature_tracker.cpp
+++ b/feature_tracker/src/feature_tracker.cpp
@@ -204,7 +204,7 @@ void FeatureTracker::readImage(const cv::Mat &_img, const cv::Mat &_mask, double
 
 void FeatureTracker::rejectWithF()
 {
-    if (forw_pts.size() >= 4)
+    if (forw_pts.size() >= 8)
     {
         ROS_DEBUG("FM ransac begins");
         TicToc t_f;
@@ -224,8 +224,8 @@ void FeatureTracker::rejectWithF()
         }
 
         vector<uchar> status;
-        //cv::findFundamentalMat(un_cur_pts, un_forw_pts, cv::FM_RANSAC, F_THRESHOLD, 0.99, status);
-        cv::findHomography(un_cur_pts, un_forw_pts, cv::RANSAC, 3, status);
+        cv::findFundamentalMat(un_cur_pts, un_forw_pts, cv::FM_RANSAC, F_THRESHOLD, 0.99, status);
+        //cv::findHomography(un_cur_pts, un_forw_pts, cv::RANSAC, 3, status);
         int size_a = cur_pts.size();
         reduceVector(prev_pts, status);
         reduceVector(cur_pts, status);
-- 
2.17.1


From 9756346e6b551d799f7610884250094d83da9488 Mon Sep 17 00:00:00 2001
From: Karnik Ram <karnikram@gmail.com>
Date: Sun, 24 Jan 2021 09:26:00 +0530
Subject: [PATCH 29/42] Clear plane parameters upon failure, fix multiple
 initialization bug

---
 vins_estimator/src/estimator.cpp       | 13 ++++++++++---
 vins_estimator/src/estimator.h         |  2 +-
 vins_estimator/src/feature_manager.cpp |  1 +
 3 files changed, 12 insertions(+), 4 deletions(-)

diff --git a/vins_estimator/src/estimator.cpp b/vins_estimator/src/estimator.cpp
index eee27b5..88e0942 100644
--- a/vins_estimator/src/estimator.cpp
+++ b/vins_estimator/src/estimator.cpp
@@ -52,6 +52,9 @@ void Estimator::clearState()
         }
     }
 
+    para_N.clear();
+    para_d.clear();
+
     solver_flag = INITIAL;
     first_imu = false,
     sum_of_back = 0;
@@ -186,7 +189,7 @@ void Estimator::processImage(const map<int, vector<pair<int, Eigen::Matrix<doubl
     else
     {
         TicToc t_solve;
-        initializePlanes();
+        initializeNewPlanes();
         solveOdometry();
         ROS_DEBUG("solver costs: %fms", t_solve.toc());
 
@@ -373,6 +376,8 @@ bool Estimator::initialStructure()
         return true;
     else
     {
+        para_N.clear();
+        para_d.clear();
         ROS_INFO("misalign visual structure with IMU");
         return false;
     }
@@ -447,6 +452,8 @@ bool Estimator::visualInitialAlign(map<int, Eigen::Vector3d> &relative_T, Eigen:
             para_d[lplane_id] = {s};
         else
            para_d[t.first] = {s*lt.norm()/t.second.norm()}; 
+
+        ROS_INFO("Initialized plane %d features", t.first);
     } 
 
     Matrix3d R0 = Utility::g2R(g);
@@ -558,7 +565,6 @@ bool Estimator::relativeHPose(map<int, Matrix3d> &relative_R, map<int, Vector3d>
                         relative_R[corres.first] = est_R;
                         relative_t[corres.first] = est_t;
                         n[corres.first] = est_n;
-                        ROS_INFO("Initialized plane %d features", corres.first);
                     }
                 }
                 return true;
@@ -568,7 +574,7 @@ bool Estimator::relativeHPose(map<int, Matrix3d> &relative_R, map<int, Vector3d>
     return false;
 }
 
-void Estimator::initializePlanes()
+void Estimator::initializeNewPlanes()
 {
     // check for new plane ids
     for(auto &plane_id : f_manager.plane_ids)
@@ -617,6 +623,7 @@ void Estimator::initializePlanes()
                         vi_t = Rs[i].transpose() * (Ps[WINDOW_SIZE - 1] - Ps[i]);
                         para_d[plane_id] = {(1.0*vi_t.norm()/est_t.norm())};
                         ROS_INFO("Initialized plane %d features", plane_id);
+                        break;
                     }
                 }
             }
diff --git a/vins_estimator/src/estimator.h b/vins_estimator/src/estimator.h
index 7c54363..35aaff8 100644
--- a/vins_estimator/src/estimator.h
+++ b/vins_estimator/src/estimator.h
@@ -42,7 +42,7 @@ class Estimator
     bool visualInitialAlign(map<int,Eigen::Vector3d> &relative_T, Eigen::Vector3d &lt);
     bool relativePose(Matrix3d &relative_R, Vector3d &relative_T, int &l);
     bool relativeHPose(map<int, Matrix3d> &relative_R, map<int, Vector3d> &relative_T, map<int, Vector3d> &n, int &l, int &lplane_id);
-    void initializePlanes();
+    void initializeNewPlanes();
     void slideWindow();
     void solveOdometry();
     void slideWindowNew();
diff --git a/vins_estimator/src/feature_manager.cpp b/vins_estimator/src/feature_manager.cpp
index 64828ee..e82c694 100644
--- a/vins_estimator/src/feature_manager.cpp
+++ b/vins_estimator/src/feature_manager.cpp
@@ -23,6 +23,7 @@ void FeatureManager::setRic(Matrix3d _ric[])
 void FeatureManager::clearState()
 {
     feature.clear();
+    plane_ids.clear();
 }
 
 int FeatureManager::getFeatureCount()
-- 
2.17.1


From 6ae97fe2b8e72f6e48bd9e857e6ee3e6d21bce44 Mon Sep 17 00:00:00 2001
From: Karnik Ram <karnikram@gmail.com>
Date: Sun, 24 Jan 2021 09:35:02 +0530
Subject: [PATCH 30/42] Add airsim config, launch files

---
 config/airsim_config.yaml                     | 83 +++++++++++++++++++
 .../launch/playback_vins_airsim.launch        | 29 +++++++
 2 files changed, 112 insertions(+)
 create mode 100644 config/airsim_config.yaml
 create mode 100644 vins_estimator/launch/playback_vins_airsim.launch

diff --git a/config/airsim_config.yaml b/config/airsim_config.yaml
new file mode 100644
index 0000000..f7dda5c
--- /dev/null
+++ b/config/airsim_config.yaml
@@ -0,0 +1,83 @@
+%YAML:1.0
+
+#common parameters
+imu_topic: "/imu"
+image_topic: "/image"
+mask_topic: "/mask"
+output_path: "/home/karnik/output/"
+
+#camera calibration 
+model_type: PINHOLE
+camera_name: camera
+image_width: 640
+image_height: 480
+distortion_parameters:
+   k1: 0
+   k2: 0
+   p1: 0
+   p2: 0
+projection_parameters:
+   fx: 320
+   fy: 320
+   cx: 320
+   cy: 240
+
+# Extrinsic parameter between IMU and Camera.
+estimate_extrinsic: 0   # 0  Have an accurate extrinsic parameters. We will trust the following imu^R_cam, imu^T_cam, don't change it.
+                        # 1  Have an initial guess about extrinsic parameters. We will optimize around your initial guess.
+                        # 2  Don't know anything about extrinsic parameters. You don't need to give R,T. We will try to calibrate it. Do some rotation movement at beginning.                        
+#If you choose 0 or 1, you should write down the following matrix.
+
+#Rotation from camera frame to imu frame, imu^R_cam
+extrinsicRotation: !!opencv-matrix
+   rows: 3
+   cols: 3
+   dt: d
+   data: [-0.00051157,-0.00020788,0.99999985,0.99999972,-0.00054877,0.00051145,0.00054867,0.99999983,0.00020816] #[0,0,1,1,0,0,0,1,0] 
+
+#Translation from camera frame to imu frame, imu^T_cam
+extrinsicTranslation: !!opencv-matrix
+   rows: 3
+   cols: 1
+   dt: d
+   data: [0.53937284, 0.02825352, 0.02064487] #[0.50,0,0]
+
+#feature traker parameters
+max_cnt: 300          # max feature number in feature tracking
+min_dist: 30            # min distance between two features 
+freq: 10                # frequence (Hz) of publish tracking result. At least 10Hz for good estimation. If set 0, the frequence will be same as raw image 
+F_threshold: 1.0        # ransac threshold (pixel)
+show_track: 1           # publish tracking image as topic
+equalize: 1             # if image is too dark or light, trun on equalize to find enough features
+fisheye: 0              # if using fisheye, trun on it. A circle mask will be loaded to remove edge noisy points
+
+#optimization parameters
+max_solver_time: 0.04  # max solver itration time (ms), to guarantee real time
+max_num_iterations: 8   # max solver itrations, to guarantee real time
+keyframe_parallax: 10.0 # keyframe selection threshold (pixel)
+
+#imu parameters       The more accurate parameters you provide, the better performance
+acc_n: 0.1          # accelerometer measurement noise standard deviation. #0.2   0.04
+gyr_n: 0.001         # gyroscope measurement noise standard deviation.     #0.05  0.004
+acc_w: 0.0002         # accelerometer bias random work noise standard deviation.  #0.02
+gyr_w: 2.0e-5       # gyroscope bias random work noise standard deviation.     #4.0e-5
+g_norm: 9.8067     # gravity magnitude
+
+#loop closure parameters
+loop_closure: 1                    # start loop closure
+load_previous_pose_graph: 0        # load and reuse previous pose graph; load from 'pose_graph_save_path'
+fast_relocalization: 0             # useful in real-time and large project
+pose_graph_save_path: "/home/karnik/" # save and load path
+
+#unsynchronization parameters
+estimate_td: 0                      # online estimate time offset between camera and imu
+td: -0.051134656900876006 # -0.04109                          # initial value of time offset. unit: s. readed image clock + td = real image clock (IMU clock)
+
+#rolling shutter parameters
+rolling_shutter: 0                  # 0: global shutter camera, 1: rolling shutter camera
+rolling_shutter_tr: 0               # unit: s. rolling shutter read out time per frame (from data sheet). 
+
+#visualization parameters
+save_image: 1                   # save image in pose graph for visualization prupose; you can close this function by setting 0 
+visualize_imu_forward: 0        # output imu forward propogation to achieve low latency and high frequence results
+visualize_camera_size: 0.4      # size of camera marker in RVIZ
diff --git a/vins_estimator/launch/playback_vins_airsim.launch b/vins_estimator/launch/playback_vins_airsim.launch
new file mode 100644
index 0000000..82ed3a8
--- /dev/null
+++ b/vins_estimator/launch/playback_vins_airsim.launch
@@ -0,0 +1,29 @@
+<launch>
+
+  <arg name="playback_rate" default="1.0" />
+  <arg name="start_from" default="20" />
+  <arg name="bagfile_path" default="/home/karnik/dataset/airsim/CustomWarehouse/capoeira_new_1/sequence.bag"/>
+
+  <arg name="config_path" default = "/home/karnik/catkin_ws/src/VINS-Mono/config/airsim_config.yaml" />
+  <arg name="vins_path" default = "$(find feature_tracker)/../config/../" />
+
+  <!-- Use sim time -->
+  <param name ="/use_sim_time" value="true"/>
+  
+  <!-- Bag playback -->
+  <node name="rosbag_playback" pkg="rosbag" type="play" required="true" args=" --delay=10 --clock --queue=1000 -r $(arg playback_rate) -s $(arg start_from) $(arg bagfile_path)"/>
+
+  <!-- VINS-Mono nodes -->
+  <node name="feature_tracker" pkg="feature_tracker" type="feature_tracker" output="log">
+    <param name="config_file" type="string" value="$(arg config_path)" />
+    <param name="vins_folder" type="string" value="$(arg vins_path)" />
+  </node>
+
+  <node name="vins_estimator" pkg="vins_estimator" type="vins_estimator" output="screen">
+    <param name="config_file" type="string" value="$(arg config_path)" />
+    <param name="vins_folder" type="string" value="$(arg vins_path)" />
+  </node>
+
+  <node name="rvizvisualisation" pkg="rviz" type="rviz" output="log" args="-d $(find vins_estimator)/../config/vins_rviz_config.rviz" />
+
+</launch>
-- 
2.17.1


From 3e110dc2125a47fd1f0bdad80065a0a2f1d0cf4f Mon Sep 17 00:00:00 2001
From: Karnik Ram <karnikram@gmail.com>
Date: Tue, 2 Feb 2021 09:19:45 +0530
Subject: [PATCH 31/42] Use only largest plane inside estimator

---
 config/airsim_config.yaml                     |  2 +-
 .../launch/playback_vins_airsim.launch        |  4 ++--
 vins_estimator/src/estimator.cpp              |  8 +++++--
 vins_estimator/src/estimator.h                |  2 ++
 vins_estimator/src/feature_manager.cpp        | 24 +++++++++++++++++++
 vins_estimator/src/feature_manager.h          |  1 +
 6 files changed, 36 insertions(+), 5 deletions(-)

diff --git a/config/airsim_config.yaml b/config/airsim_config.yaml
index f7dda5c..ed9c012 100644
--- a/config/airsim_config.yaml
+++ b/config/airsim_config.yaml
@@ -43,7 +43,7 @@ extrinsicTranslation: !!opencv-matrix
    data: [0.53937284, 0.02825352, 0.02064487] #[0.50,0,0]
 
 #feature traker parameters
-max_cnt: 300          # max feature number in feature tracking
+max_cnt: 250          # max feature number in feature tracking
 min_dist: 30            # min distance between two features 
 freq: 10                # frequence (Hz) of publish tracking result. At least 10Hz for good estimation. If set 0, the frequence will be same as raw image 
 F_threshold: 1.0        # ransac threshold (pixel)
diff --git a/vins_estimator/launch/playback_vins_airsim.launch b/vins_estimator/launch/playback_vins_airsim.launch
index 82ed3a8..e86876a 100644
--- a/vins_estimator/launch/playback_vins_airsim.launch
+++ b/vins_estimator/launch/playback_vins_airsim.launch
@@ -1,8 +1,8 @@
 <launch>
 
   <arg name="playback_rate" default="1.0" />
-  <arg name="start_from" default="20" />
-  <arg name="bagfile_path" default="/home/karnik/dataset/airsim/CustomWarehouse/capoeira_new_1/sequence.bag"/>
+  <arg name="start_from" default="0" />
+  <arg name="bagfile_path" default="/home/karnik/dataset/airsim/CustomWarehouse/static_new_15_1/sequence.bag"/>
 
   <arg name="config_path" default = "/home/karnik/catkin_ws/src/VINS-Mono/config/airsim_config.yaml" />
   <arg name="vins_path" default = "$(find feature_tracker)/../config/../" />
diff --git a/vins_estimator/src/estimator.cpp b/vins_estimator/src/estimator.cpp
index 88e0942..89d5b15 100644
--- a/vins_estimator/src/estimator.cpp
+++ b/vins_estimator/src/estimator.cpp
@@ -54,6 +54,7 @@ void Estimator::clearState()
 
     para_N.clear();
     para_d.clear();
+    init_pids.clear();
 
     solver_flag = INITIAL;
     first_imu = false,
@@ -453,6 +454,7 @@ bool Estimator::visualInitialAlign(map<int, Eigen::Vector3d> &relative_T, Eigen:
         else
            para_d[t.first] = {s*lt.norm()/t.second.norm()}; 
 
+        init_pids.push_back(t.first);
         ROS_INFO("Initialized plane %d features", t.first);
     } 
 
@@ -622,6 +624,7 @@ void Estimator::initializeNewPlanes()
                         // Estimate plane d using known metric t from vio 
                         vi_t = Rs[i].transpose() * (Ps[WINDOW_SIZE - 1] - Ps[i]);
                         para_d[plane_id] = {(1.0*vi_t.norm()/est_t.norm())};
+                        init_pids.push_back(plane_id);
                         ROS_INFO("Initialized plane %d features", plane_id);
                         break;
                     }
@@ -886,6 +889,8 @@ void Estimator::optimization()
     }
     int f_m_cnt = 0;
     int feature_index = -1;
+    int largest_pid = f_manager.getLargestPlaneId(init_pids);
+    ROS_INFO("Using features from plane %d", largest_pid);
     for (auto &it_per_id : f_manager.feature)
     {
         it_per_id.used_num = it_per_id.feature_per_frame.size();
@@ -899,7 +904,7 @@ void Estimator::optimization()
         Vector3d pts_i = it_per_id.feature_per_frame[0].point;
         int pid = it_per_id.plane_id;
 
-        if(!(para_N.count(pid) > 0 && para_d.count(pid) > 0))
+        if(pid != largest_pid)
             continue;
 
         for (auto &it_per_frame : it_per_id.feature_per_frame)
@@ -974,7 +979,6 @@ void Estimator::optimization()
                 }
             }
         }
-
     }
 
     ceres::Solver::Options options;
diff --git a/vins_estimator/src/estimator.h b/vins_estimator/src/estimator.h
index 35aaff8..49cd656 100644
--- a/vins_estimator/src/estimator.h
+++ b/vins_estimator/src/estimator.h
@@ -120,6 +120,8 @@ class Estimator
     map<int, array<double,4>> para_N;
     map<int, array<double,1>> para_d;
 
+    vector<int> init_pids;
+
     int loop_window_index;
 
     MarginalizationInfo *last_marginalization_info;
diff --git a/vins_estimator/src/feature_manager.cpp b/vins_estimator/src/feature_manager.cpp
index e82c694..16cf5e5 100644
--- a/vins_estimator/src/feature_manager.cpp
+++ b/vins_estimator/src/feature_manager.cpp
@@ -42,6 +42,30 @@ int FeatureManager::getFeatureCount()
     return cnt;
 }
 
+int FeatureManager::getLargestPlaneId(std::vector<int> &init_pids)
+{
+    std::map<int, int> plane_counts;
+    for(auto &pid : init_pids)
+        plane_counts[pid] = 0;
+
+    for(auto &it : feature)
+    {
+        if(plane_counts.count(it.plane_id) > 0)
+            plane_counts[it.plane_id]++;
+    }
+
+    int largest_count = 0, largest_pid;
+    for(auto &plane_count : plane_counts)
+    {   
+        if(plane_count.second > largest_count)
+        {
+            largest_count = plane_count.second;
+            largest_pid = plane_count.first;
+        }
+    }
+    
+    return largest_pid;
+}
 
 bool FeatureManager::addFeatureCheckParallax(int frame_count, const map<int, vector<pair<int, Eigen::Matrix<double, 8, 1>>>> &image, double td)
 {
diff --git a/vins_estimator/src/feature_manager.h b/vins_estimator/src/feature_manager.h
index a7f46fc..1080e7f 100644
--- a/vins_estimator/src/feature_manager.h
+++ b/vins_estimator/src/feature_manager.h
@@ -75,6 +75,7 @@ class FeatureManager
     void clearState();
 
     int getFeatureCount();
+    int getLargestPlaneId(std::vector<int> &init_pids);
 
     bool addFeatureCheckParallax(int frame_count, const map<int, vector<pair<int, Eigen::Matrix<double, 8, 1>>>> &image, double td);
     void debugShow();
-- 
2.17.1


From 20033975cd339f20def81dab5904dd2843d692cc Mon Sep 17 00:00:00 2001
From: Karnik Ram <karnikram@gmail.com>
Date: Thu, 4 Feb 2021 09:46:20 +0530
Subject: [PATCH 32/42] Enforce unit N using homo parameterization

---
 .../launch/playback_vins_airsim.launch        |  3 ++-
 vins_estimator/src/estimator.cpp              |  8 ++++----
 vins_estimator/src/estimator.h                |  2 +-
 vins_estimator/src/factor/homography_factor.h |  7 +++----
 vins_estimator/src/initial/initial_sfm.cpp    | 20 +++++++++----------
 vins_estimator/src/initial/initial_sfm.h      |  4 ++--
 6 files changed, 22 insertions(+), 22 deletions(-)

diff --git a/vins_estimator/launch/playback_vins_airsim.launch b/vins_estimator/launch/playback_vins_airsim.launch
index e86876a..61d8cac 100644
--- a/vins_estimator/launch/playback_vins_airsim.launch
+++ b/vins_estimator/launch/playback_vins_airsim.launch
@@ -2,7 +2,7 @@
 
   <arg name="playback_rate" default="1.0" />
   <arg name="start_from" default="0" />
-  <arg name="bagfile_path" default="/home/karnik/dataset/airsim/CustomWarehouse/static_new_15_1/sequence.bag"/>
+  <arg name="bagfile_path" default="/home/karnik/dataset/airsim/CustomWarehouse/final/static/sequence.bag"/>
 
   <arg name="config_path" default = "/home/karnik/catkin_ws/src/VINS-Mono/config/airsim_config.yaml" />
   <arg name="vins_path" default = "$(find feature_tracker)/../config/../" />
@@ -26,4 +26,5 @@
 
   <node name="rvizvisualisation" pkg="rviz" type="rviz" output="log" args="-d $(find vins_estimator)/../config/vins_rviz_config.rviz" />
 
+ <node name="throttle" pkg="topic_tools" type="throttle" args="messages /imu 200 /imu_throttled"/>
 </launch>
diff --git a/vins_estimator/src/estimator.cpp b/vins_estimator/src/estimator.cpp
index 89d5b15..d4ec043 100644
--- a/vins_estimator/src/estimator.cpp
+++ b/vins_estimator/src/estimator.cpp
@@ -302,7 +302,7 @@ bool Estimator::initialStructure()
     // Save estimated normal variables
     for(auto &est_n : n)
     {
-        para_N[est_n.first] = {0, est_n.second(0), est_n.second(1), est_n.second(2)};
+        para_N[est_n.first] = {est_n.second(0), est_n.second(1), est_n.second(2)};
     }
 
     //solve pnp for all frame
@@ -619,7 +619,7 @@ void Estimator::initializeNewPlanes()
                     {
                         // Transform est_n to global frame
                         est_n = Rs[i] * est_n;
-                        para_N[plane_id] = {0, est_n(0), est_n(1), est_n(2)};
+                        para_N[plane_id] = {est_n(0), est_n(1), est_n(2)};
 
                         // Estimate plane d using known metric t from vio 
                         vi_t = Rs[i].transpose() * (Ps[WINDOW_SIZE - 1] - Ps[i]);
@@ -846,8 +846,8 @@ void Estimator::optimization()
 
     for(auto &N : para_N)
     {
-        ceres::LocalParameterization *local_n_parameterization = new ceres::QuaternionParameterization();
-        problem.AddParameterBlock(N.second.data(), 4, local_n_parameterization);
+        ceres::LocalParameterization *local_n_parameterization = new ceres::HomogeneousVectorParameterization(3);
+        problem.AddParameterBlock(N.second.data(), 3, local_n_parameterization);
     }
 
     for (int i = 0; i < NUM_OF_CAM; i++)
diff --git a/vins_estimator/src/estimator.h b/vins_estimator/src/estimator.h
index 49cd656..e794866 100644
--- a/vins_estimator/src/estimator.h
+++ b/vins_estimator/src/estimator.h
@@ -117,7 +117,7 @@ class Estimator
     double para_Retrive_Pose[SIZE_POSE];
     double para_Td[1][1];
     double para_Tr[1][1];
-    map<int, array<double,4>> para_N;
+    map<int, array<double,3>> para_N;
     map<int, array<double,1>> para_d;
 
     vector<int> init_pids;
diff --git a/vins_estimator/src/factor/homography_factor.h b/vins_estimator/src/factor/homography_factor.h
index ce6612b..adb6397 100644
--- a/vins_estimator/src/factor/homography_factor.h
+++ b/vins_estimator/src/factor/homography_factor.h
@@ -22,10 +22,9 @@ struct HomographyFactor
             Eigen::Quaternion<T> qic;
             qic.coeffs() << ex_pose[3], ex_pose[4], ex_pose[5], ex_pose[6];
 
-            Eigen::Map<const Eigen::Matrix<T, 4, 1>> q_n(para_n);
             Eigen::Matrix<T, 3, 1> n;
-            n << q_n[1], q_n[2], q_n[3];
-            Eigen::Matrix<T, 3, 1> n_imu_1 = qic*(n.normalized()) + tic;
+            n << para_n[0], para_n[1], para_n[2];
+            Eigen::Matrix<T, 3, 1> n_imu_1 = qic*n + tic;
             Eigen::Matrix<T, 3, 1> n_imu_i = qi.inverse()*n_imu_1 - qi.inverse()*pi;
 
             Eigen::Map<const Eigen::Matrix<T, 1, 1>> inv_depth(para_inv_depth);
@@ -47,7 +46,7 @@ struct HomographyFactor
 
     static ceres::CostFunction* Create(const Eigen::Vector3d &_pts_i, const Eigen::Vector3d &_pts_j)
     {
-        return (new ceres::AutoDiffCostFunction<HomographyFactor, 2, 7, 7, 4, 1, 7>
+        return (new ceres::AutoDiffCostFunction<HomographyFactor, 2, 7, 7, 3, 1, 7>
                 (new HomographyFactor(_pts_i, _pts_j)));
     }
 
diff --git a/vins_estimator/src/initial/initial_sfm.cpp b/vins_estimator/src/initial/initial_sfm.cpp
index ad9f729..7726410 100644
--- a/vins_estimator/src/initial/initial_sfm.cpp
+++ b/vins_estimator/src/initial/initial_sfm.cpp
@@ -342,7 +342,7 @@ bool GlobalSFM::constructH(int frame_num, Quaterniond* q, Vector3d* T, int l,
 	Quaterniond c_Quat[frame_num];
 	double c_rotation[frame_num][4];
 	double c_translation[frame_num][3];
-    double c_normal[4];
+    double c_normal[3];
 	Eigen::Matrix<double, 3, 4> Pose[frame_num];
 
 	c_Quat[l] = q[l].inverse();
@@ -420,7 +420,7 @@ bool GlobalSFM::constructH(int frame_num, Quaterniond* q, Vector3d* T, int l,
             sfm_f[j].image[1] = point1[1];
             sfm_f[j].image[2] = 1;
 			//cout << "trangulated : " << frame_0 << " " << frame_1 << "  3d point : "  << j << "  " << point_3d.transpose() << endl;
-		}		
+		}	
 	}
 
 /*
@@ -439,6 +439,7 @@ bool GlobalSFM::constructH(int frame_num, Quaterniond* q, Vector3d* T, int l,
 	//full BA
 	ceres::Problem problem;
 	ceres::LocalParameterization* local_parameterization = new ceres::QuaternionParameterization();
+	ceres::LocalParameterization* local_n_parameterization = new ceres::HomogeneousVectorParameterization(3);
 	//cout << " begin full BA " << endl;
 	for (int i = 0; i < frame_num; i++)
 	{
@@ -462,11 +463,10 @@ bool GlobalSFM::constructH(int frame_num, Quaterniond* q, Vector3d* T, int l,
 		}
 	}
 
-	c_normal[0] = 0;
-    c_normal[1] = n[0];
-    c_normal[2] = n[1];
-    c_normal[3] = n[2];
-    problem.AddParameterBlock(c_normal, 4, local_parameterization);
+    c_normal[0] = n[0];
+    c_normal[1] = n[1];
+    c_normal[2] = n[2];
+    problem.AddParameterBlock(c_normal, 3, local_n_parameterization);
 
 	for (int i = 0; i < feature_num; i++)
 	{
@@ -527,9 +527,9 @@ bool GlobalSFM::constructH(int frame_num, Quaterniond* q, Vector3d* T, int l,
 			sfm_tracked_points[sfm_f[i].id] = Vector3d(sfm_f[i].position[0], sfm_f[i].position[1], sfm_f[i].position[2]);
 	}
 
-    n[0] = c_normal[1];
-    n[1] = c_normal[2];
-    n[2] = c_normal[3];
+    n[0] = c_normal[0];
+    n[1] = c_normal[1];
+    n[2] = c_normal[2];
 
 	return true;
 
diff --git a/vins_estimator/src/initial/initial_sfm.h b/vins_estimator/src/initial/initial_sfm.h
index 3c51e44..2ee3418 100644
--- a/vins_estimator/src/initial/initial_sfm.h
+++ b/vins_estimator/src/initial/initial_sfm.h
@@ -67,7 +67,7 @@ struct ReprojectionErrorH
 	{
 		T rp[3];
         ceres::QuaternionRotatePoint(R, point, rp);
-        T np = n[1] * point[0] + n[2] * point[1] + n[3] * point[2];
+        T np = n[0] * point[0] + n[1] * point[1] + n[2] * point[2];
         rp[0] += t[0]*np; rp[1] += t[1]*np; rp[2] += t[2]*np;
 		T xp = rp[0] / rp[2];
     	T yp = rp[1] / rp[2];
@@ -80,7 +80,7 @@ struct ReprojectionErrorH
 	                                   const double observed_y) 
 	{
 	  return (new ceres::AutoDiffCostFunction<
-	          ReprojectionErrorH, 2, 4, 3, 4, 3>(
+	          ReprojectionErrorH, 2, 4, 3, 3, 3>(
 	          	new ReprojectionErrorH(observed_x,observed_y)));
 	}
 
-- 
2.17.1


From 8e05539a6ebdaa1ebe9e867551124d7cd7867ee3 Mon Sep 17 00:00:00 2001
From: Karnik Ram <karnikram@gmail.com>
Date: Tue, 9 Feb 2021 09:22:40 +0530
Subject: [PATCH 33/42] Fix bug in normal transformation

---
 vins_estimator/src/factor/homography_factor.h | 4 ++--
 vins_estimator/src/initial/initial_sfm.cpp    | 2 +-
 vins_estimator/src/initial/initial_sfm.h      | 7 +++----
 3 files changed, 6 insertions(+), 7 deletions(-)

diff --git a/vins_estimator/src/factor/homography_factor.h b/vins_estimator/src/factor/homography_factor.h
index adb6397..7107036 100644
--- a/vins_estimator/src/factor/homography_factor.h
+++ b/vins_estimator/src/factor/homography_factor.h
@@ -24,8 +24,8 @@ struct HomographyFactor
 
             Eigen::Matrix<T, 3, 1> n;
             n << para_n[0], para_n[1], para_n[2];
-            Eigen::Matrix<T, 3, 1> n_imu_1 = qic*n + tic;
-            Eigen::Matrix<T, 3, 1> n_imu_i = qi.inverse()*n_imu_1 - qi.inverse()*pi;
+            Eigen::Matrix<T, 3, 1> n_imu_1 = qic*n;// + tic;
+            Eigen::Matrix<T, 3, 1> n_imu_i = qi.inverse()*n_imu_1;// - qi.inverse()*pi;
 
             Eigen::Map<const Eigen::Matrix<T, 1, 1>> inv_depth(para_inv_depth);
 
diff --git a/vins_estimator/src/initial/initial_sfm.cpp b/vins_estimator/src/initial/initial_sfm.cpp
index 7726410..f319bd9 100644
--- a/vins_estimator/src/initial/initial_sfm.cpp
+++ b/vins_estimator/src/initial/initial_sfm.cpp
@@ -481,7 +481,7 @@ bool GlobalSFM::constructH(int frame_num, Quaterniond* q, Vector3d* T, int l,
 												sfm_f[i].observation[j].second.y());
 
     		problem.AddResidualBlock(b_cost_function, NULL, c_rotation[l], c_translation[l],
-    								sfm_f[i].position); 
+    								sfm_f[i].position);
 
 			ceres::CostFunction* h_cost_function = ReprojectionErrorH::Create(
 												sfm_f[i].observation[j].second.x(),
diff --git a/vins_estimator/src/initial/initial_sfm.h b/vins_estimator/src/initial/initial_sfm.h
index 2ee3418..9699356 100644
--- a/vins_estimator/src/initial/initial_sfm.h
+++ b/vins_estimator/src/initial/initial_sfm.h
@@ -11,8 +11,6 @@
 using namespace Eigen;
 using namespace std;
 
-
-
 struct SFMFeature
 {
     bool state;
@@ -66,8 +64,9 @@ struct ReprojectionErrorH
 	bool operator()(const T* const R, const T* const t, const T* const n, const T* point, T* residuals) const
 	{
 		T rp[3];
-        ceres::QuaternionRotatePoint(R, point, rp);
-        T np = n[0] * point[0] + n[1] * point[1] + n[2] * point[2];
+		T norm_point[3] = {point[0]/point[2], point[1]/point[2], point[2]/point[2]};
+        ceres::QuaternionRotatePoint(R, norm_point, rp);
+        T np = n[0] * norm_point[0] + n[1] * norm_point[1] + n[2] * norm_point[2];
         rp[0] += t[0]*np; rp[1] += t[1]*np; rp[2] += t[2]*np;
 		T xp = rp[0] / rp[2];
     	T yp = rp[1] / rp[2];
-- 
2.17.1


From e5f5255debd246caf27345f43b185b5bc58d968b Mon Sep 17 00:00:00 2001
From: Karnik Ram <karnikram@gmail.com>
Date: Tue, 9 Feb 2021 09:23:13 +0530
Subject: [PATCH 34/42] Modify config

---
 config/hvins_airsim_config.yaml               | 83 +++++++++++++++++++
 .../launch/playback_vins_airsim.launch        |  4 +-
 2 files changed, 85 insertions(+), 2 deletions(-)
 create mode 100644 config/hvins_airsim_config.yaml

diff --git a/config/hvins_airsim_config.yaml b/config/hvins_airsim_config.yaml
new file mode 100644
index 0000000..5af6480
--- /dev/null
+++ b/config/hvins_airsim_config.yaml
@@ -0,0 +1,83 @@
+%YAML:1.0
+
+#common parameters
+imu_topic: "/imu_throttled"
+image_topic: "/image"
+mask_topic: "/mask"
+output_path: "/home/karnik/output/"
+
+#camera calibration 
+model_type: PINHOLE
+camera_name: camera
+image_width: 640
+image_height: 480
+distortion_parameters:
+   k1: 0
+   k2: 0
+   p1: 0
+   p2: 0
+projection_parameters:
+   fx: 320
+   fy: 320
+   cx: 320
+   cy: 240
+
+# Extrinsic parameter between IMU and Camera.
+estimate_extrinsic: 0   # 0  Have an accurate extrinsic parameters. We will trust the following imu^R_cam, imu^T_cam, don't change it.
+                        # 1  Have an initial guess about extrinsic parameters. We will optimize around your initial guess.
+                        # 2  Don't know anything about extrinsic parameters. You don't need to give R,T. We will try to calibrate it. Do some rotation movement at beginning.                        
+#If you choose 0 or 1, you should write down the following matrix.
+
+#Rotation from camera frame to imu frame, imu^R_cam
+extrinsicRotation: !!opencv-matrix
+   rows: 3
+   cols: 3
+   dt: d
+   data: [-0.00017913,-0.00042042,0.9999999,0.99999996,-0.00023746, 0.00017903,0.00023739,0.99999988,0.00042046] #[0,0,1,1,0,0,0,1,0] 
+
+#Translation from camera frame to imu frame, imu^T_cam
+extrinsicTranslation: !!opencv-matrix
+   rows: 3
+   cols: 1
+   dt: d
+   data: [0.49118794, 0.02176473, 0.01374164] #[0.50,0,0]
+
+#feature traker parameters
+max_cnt: 150          # max feature number in feature tracking
+min_dist: 30            # min distance between two features 
+freq: 10                # frequence (Hz) of publish tracking result. At least 10Hz for good estimation. If set 0, the frequence will be same as raw image 
+F_threshold: 1.0        # ransac threshold (pixel)
+show_track: 1           # publish tracking image as topic
+equalize: 1             # if image is too dark or light, trun on equalize to find enough features
+fisheye: 0              # if using fisheye, trun on it. A circle mask will be loaded to remove edge noisy points
+
+#optimization parameters
+max_solver_time: 0.04  # max solver itration time (ms), to guarantee real time
+max_num_iterations: 8   # max solver itrations, to guarantee real time
+keyframe_parallax: 10.0 # keyframe selection threshold (pixel)
+
+#imu parameters       The more accurate parameters you provide, the better performance
+acc_n: 0.074427240          # accelerometer measurement noise standard deviation. #0.2   0.04
+gyr_n: 0.002759607         # gyroscope measurement noise standard deviation.     #0.05  0.004
+acc_w: 3.9471004e-7         # accelerometer bias random work noise standard deviation.  #0.02
+gyr_w: 3.1538983e-8       # gyroscope bias random work noise standard deviation.     #4.0e-5
+g_norm: 9.80665     # gravity magnitude
+
+#loop closure parameters
+loop_closure: 1                    # start loop closure
+load_previous_pose_graph: 0        # load and reuse previous pose graph; load from 'pose_graph_save_path'
+fast_relocalization: 0             # useful in real-time and large project
+pose_graph_save_path: "/home/karnik/" # save and load path
+
+#unsynchronization parameters
+estimate_td: 0                      # online estimate time offset between camera and imu
+td: -0.03079132514112524 # -0.04109                          # initial value of time offset. unit: s. readed image clock + td = real image clock (IMU clock)
+
+#rolling shutter parameters
+rolling_shutter: 0                  # 0: global shutter camera, 1: rolling shutter camera
+rolling_shutter_tr: 0               # unit: s. rolling shutter read out time per frame (from data sheet). 
+
+#visualization parameters
+save_image: 1                   # save image in pose graph for visualization prupose; you can close this function by setting 0 
+visualize_imu_forward: 0        # output imu forward propogation to achieve low latency and high frequence results
+visualize_camera_size: 0.4      # size of camera marker in RVIZ
diff --git a/vins_estimator/launch/playback_vins_airsim.launch b/vins_estimator/launch/playback_vins_airsim.launch
index 61d8cac..9925a21 100644
--- a/vins_estimator/launch/playback_vins_airsim.launch
+++ b/vins_estimator/launch/playback_vins_airsim.launch
@@ -8,10 +8,10 @@
   <arg name="vins_path" default = "$(find feature_tracker)/../config/../" />
 
   <!-- Use sim time -->
-  <param name ="/use_sim_time" value="true"/>
+  <param name ="/use_sim_time" value="false"/>
   
   <!-- Bag playback -->
-  <node name="rosbag_playback" pkg="rosbag" type="play" required="true" args=" --delay=10 --clock --queue=1000 -r $(arg playback_rate) -s $(arg start_from) $(arg bagfile_path)"/>
+  <node name="rosbag_playback" pkg="rosbag" type="play" required="true" args=" --delay=10 --queue=1000 -r $(arg playback_rate) -s $(arg start_from) $(arg bagfile_path)"/>
 
   <!-- VINS-Mono nodes -->
   <node name="feature_tracker" pkg="feature_tracker" type="feature_tracker" output="log">
-- 
2.17.1


From 2de4f06206bb221405ffa3e10f99766d6e0847e0 Mon Sep 17 00:00:00 2001
From: Karnik Ram <karnikram@gmail.com>
Date: Thu, 11 Feb 2021 11:13:51 +0530
Subject: [PATCH 35/42] Modify config, use only H inliers for mean vector

---
 config/hvins_airsim_config.yaml           |  2 +-
 config/vins_rviz_config.rviz              | 10 +++++-----
 vins_estimator/src/initial/solve_5pts.cpp | 18 +++++++++++-------
 3 files changed, 17 insertions(+), 13 deletions(-)

diff --git a/config/hvins_airsim_config.yaml b/config/hvins_airsim_config.yaml
index 5af6480..55546be 100644
--- a/config/hvins_airsim_config.yaml
+++ b/config/hvins_airsim_config.yaml
@@ -43,7 +43,7 @@ extrinsicTranslation: !!opencv-matrix
    data: [0.49118794, 0.02176473, 0.01374164] #[0.50,0,0]
 
 #feature traker parameters
-max_cnt: 150          # max feature number in feature tracking
+max_cnt: 200          # max feature number in feature tracking
 min_dist: 30            # min distance between two features 
 freq: 10                # frequence (Hz) of publish tracking result. At least 10Hz for good estimation. If set 0, the frequence will be same as raw image 
 F_threshold: 1.0        # ransac threshold (pixel)
diff --git a/config/vins_rviz_config.rviz b/config/vins_rviz_config.rviz
index 55ed131..e0c3a51 100644
--- a/config/vins_rviz_config.rviz
+++ b/config/vins_rviz_config.rviz
@@ -6,7 +6,7 @@ Panels:
       Expanded:
         - /VIO1
       Splitter Ratio: 0.4651159942150116
-    Tree Height: 151
+    Tree Height: 140
   - Class: rviz/Selection
     Name: Selection
   - Class: rviz/Tool Properties
@@ -295,7 +295,7 @@ Visualization Manager:
           Queue Size: 100
           Value: true
         - Class: rviz/Image
-          Enabled: true
+          Enabled: false
           Image Topic: /pose_graph/match_image
           Max Value: 1
           Median window: 5
@@ -305,7 +305,7 @@ Visualization Manager:
           Queue Size: 2
           Transport Hint: raw
           Unreliable: false
-          Value: true
+          Value: false
         - Class: rviz/Marker
           Enabled: true
           Marker Topic: /pose_graph/key_odometrys
@@ -506,7 +506,7 @@ Window Geometry:
   Height: 734
   Hide Left Dock: false
   Hide Right Dock: true
-  QMainWindow State: 000000ff00000000fd00000004000000000000015600000243fc0200000010fb0000000a0049006d00610067006501000000280000013d0000000000000000fb0000001200530065006c0065006300740069006f006e00000001e10000009b0000005c00fffffffb0000001e0054006f006f006c002000500072006f007000650072007400690065007302000001ed000001df00000185000000a3fb000000120056006900650077007300200054006f006f02000001df000002110000018500000122fb000000200054006f006f006c002000500072006f0070006500720074006900650073003203000002880000011d000002210000017afb0000002000730065006c0065006300740069006f006e00200062007500660066006500720200000138000000aa0000023a00000294fb00000014005700690064006500530074006500720065006f02000000e6000000d2000003ee0000030bfb0000000c004b0069006e0065006300740200000186000001060000030c00000261fb0000001200720061007700200049006d0061006700650000000028000000300000000000000000fb00000012007200610077005f0069006d0061006700650000000028000000f90000001600fffffffb0000001a0074007200610063006b0065006400200069006d006100670065010000003d000000de0000001600fffffffb00000020006c006f006f0070005f006d0061007400630068005f0069006d0061006700650100000121000000850000001600fffffffb000000100044006900730070006c00610079007301000001ac000000d4000000c900fffffffc000000280000011e0000000000fffffffa000000000100000002fb0000001200720061007700200049006d0061006700650000000000ffffffff0000000000000000fb0000001a0074007200610063006b0065006400200069006d0061006700650100000000000002370000000000000000fb0000001000410052005f0069006d0061006700650100000373000000160000000000000000fb0000001200720061007700200069006d006100670065010000038f000000160000000000000000000000010000020800000399fc0200000003fb0000001e0054006f006f006c002000500072006f00700065007200740069006500730100000041000000780000000000000000fc00000028000003990000000000fffffffaffffffff0100000002fb000000100044006900730070006c0061007900730000000000ffffffff0000015600fffffffb0000000a00560069006500770073000000023f0000016a0000010000fffffffb0000001200530065006c0065006300740069006f006e010000025a000000b200000000000000000000000200000490000000a9fc0100000001fb0000000a00560069006500770073030000004e00000080000002e10000019700000003000002a30000003bfc0100000002fb0000000800540069006d00650100000000000002a3000002eb00fffffffb0000000800540069006d00650100000000000004500000000000000000000001470000024300000004000000040000000800000008fc0000000100000002000000010000000a0054006f006f006c00730100000000ffffffff0000000000000000
+  QMainWindow State: 000000ff00000000fd00000004000000000000015600000243fc0200000010fb0000000a0049006d00610067006501000000280000013d0000000000000000fb0000001200530065006c0065006300740069006f006e00000001e10000009b0000005c00fffffffb0000001e0054006f006f006c002000500072006f007000650072007400690065007302000001ed000001df00000185000000a3fb000000120056006900650077007300200054006f006f02000001df000002110000018500000122fb000000200054006f006f006c002000500072006f0070006500720074006900650073003203000002880000011d000002210000017afb0000002000730065006c0065006300740069006f006e00200062007500660066006500720200000138000000aa0000023a00000294fb00000014005700690064006500530074006500720065006f02000000e6000000d2000003ee0000030bfb0000000c004b0069006e0065006300740200000186000001060000030c00000261fb0000001200720061007700200049006d0061006700650000000028000000300000000000000000fb00000012007200610077005f0069006d0061006700650000000028000000f90000001600fffffffb0000001a0074007200610063006b0065006400200069006d006100670065010000003d000001740000001600fffffffb00000020006c006f006f0070005f006d0061007400630068005f0069006d0061006700650000000121000000850000001600fffffffb000000100044006900730070006c00610079007301000001b7000000c9000000c900fffffffc000000280000011e0000000000fffffffa000000000100000002fb0000001200720061007700200049006d0061006700650000000000ffffffff0000000000000000fb0000001a0074007200610063006b0065006400200069006d0061006700650100000000000002370000000000000000fb0000001000410052005f0069006d0061006700650100000373000000160000000000000000fb0000001200720061007700200069006d006100670065010000038f000000160000000000000000000000010000020800000399fc0200000003fb0000001e0054006f006f006c002000500072006f00700065007200740069006500730100000041000000780000000000000000fc00000028000003990000000000fffffffaffffffff0100000002fb000000100044006900730070006c0061007900730000000000ffffffff0000015600fffffffb0000000a00560069006500770073000000023f0000016a0000010000fffffffb0000001200530065006c0065006300740069006f006e010000025a000000b200000000000000000000000200000490000000a9fc0100000001fb0000000a00560069006500770073030000004e00000080000002e10000019700000003000002eb0000003bfc0100000002fb0000000800540069006d00650100000000000002eb000002eb00fffffffb0000000800540069006d006501000000000000045000000000000000000000018f0000024300000004000000040000000800000008fc0000000100000002000000010000000a0054006f006f006c00730100000000ffffffff0000000000000000
   Selection:
     collapsed: false
   Time:
@@ -515,7 +515,7 @@ Window Geometry:
     collapsed: false
   Views:
     collapsed: true
-  Width: 675
+  Width: 747
   X: 685
   Y: 4
   loop_match_image:
diff --git a/vins_estimator/src/initial/solve_5pts.cpp b/vins_estimator/src/initial/solve_5pts.cpp
index a14ec1c..f7aa380 100644
--- a/vins_estimator/src/initial/solve_5pts.cpp
+++ b/vins_estimator/src/initial/solve_5pts.cpp
@@ -240,19 +240,23 @@ bool MotionEstimator::solveRelativeHRT(const vector<pair<Vector3d, Vector3d>> &c
         }
         cv::Mat mask;
         //cv::Mat E = cv::findFundamentalMat(ll, rr, cv::FM_RANSAC, 0.3 / 460, 0.99, mask);
-        cv::Mat H = cv::findHomography(ll, rr, cv::RANSAC, 0.3/480);
+        cv::Mat H = cv::findHomography(ll, rr, cv::RANSAC, 0.3/460, mask, 2000, 0.99);
         cv::Mat K = (cv::Mat_<double>(3, 3) << 1, 0, 0, 0, 1, 0, 0, 0, 1);
 
         // Compute mean point vector
         Eigen::Vector3d mean_l(0, 0, 1);
-        for(cv::Point2f &point : ll)
+        int inlier_count = 0;
+        for(int i = 0; i < ll.size(); i++)
         {
-            mean_l(0) += point.x;
-            mean_l(1) += point.y;
+            if(mask.at<uchar>(i,0) != 0)
+            {
+                mean_l(0) += ll[i].x;
+                mean_l(1) += ll[i].y;
+                inlier_count++;
+            }
         }
-
-        mean_l(0) /= int(ll.size());
-        mean_l(1) /= int(ll.size());
+        mean_l(0) /= int(inlier_count);
+        mean_l(1) /= int(inlier_count);
 
         Eigen::Matrix4d est_Tr;
         Eigen::Vector3d est_n;
-- 
2.17.1


From 518208852f13b10d7ebc3efaa254564c09f35a46 Mon Sep 17 00:00:00 2001
From: Karnik Ram <karnikram@gmail.com>
Date: Thu, 11 Feb 2021 20:22:00 +0530
Subject: [PATCH 36/42] Consider mask during feature tracking as well, use H
 for feature rejection instead of F

---
 config/hvins_airsim_config.yaml         |  4 +--
 feature_tracker/src/feature_tracker.cpp | 45 +++++++++++++++++--------
 feature_tracker/src/feature_tracker.h   |  4 +--
 3 files changed, 35 insertions(+), 18 deletions(-)

diff --git a/config/hvins_airsim_config.yaml b/config/hvins_airsim_config.yaml
index 55546be..7847070 100644
--- a/config/hvins_airsim_config.yaml
+++ b/config/hvins_airsim_config.yaml
@@ -43,10 +43,10 @@ extrinsicTranslation: !!opencv-matrix
    data: [0.49118794, 0.02176473, 0.01374164] #[0.50,0,0]
 
 #feature traker parameters
-max_cnt: 200          # max feature number in feature tracking
+max_cnt: 250          # max feature number in feature tracking
 min_dist: 30            # min distance between two features 
 freq: 10                # frequence (Hz) of publish tracking result. At least 10Hz for good estimation. If set 0, the frequence will be same as raw image 
-F_threshold: 1.0        # ransac threshold (pixel)
+H_threshold: 1.0        # ransac threshold (pixel)
 show_track: 1           # publish tracking image as topic
 equalize: 1             # if image is too dark or light, trun on equalize to find enough features
 fisheye: 0              # if using fisheye, trun on it. A circle mask will be loaded to remove edge noisy points
diff --git a/feature_tracker/src/feature_tracker.cpp b/feature_tracker/src/feature_tracker.cpp
index 6548c36..5537c6b 100644
--- a/feature_tracker/src/feature_tracker.cpp
+++ b/feature_tracker/src/feature_tracker.cpp
@@ -32,13 +32,12 @@ FeatureTracker::FeatureTracker()
 {
 }
 
-void FeatureTracker::setMask()
+void FeatureTracker::setMask(const cv::Mat &_mask)
 {
-    if(FISHEYE)
-        mask = fisheye_mask.clone();
-    else
-        mask = cv::Mat(ROW, COL, CV_8UC1, cv::Scalar(255));
-    
+    //mask = cv::Mat(ROW, COL, CV_8UC1, cv::Scalar(255));
+    mask = _mask.clone();
+    //cv::Mat erosion_mat = cv::getStructuringElement(cv::MORPH_RECT, cv::Size(21,21));
+    cv::erode(mask, mask, cv::Mat(), cv::Point(-1, -1), 2, 1, 1);
 
     // prefer to keep features that are tracked for long time
     vector<pair<int, pair<cv::Point2f, pair<int,int>>>> cnt_pts_id_pid;
@@ -61,7 +60,7 @@ void FeatureTracker::setMask()
 
     for (auto &it : cnt_pts_id_pid)
     {
-        if (mask.at<uchar>(it.second.first) == 255)
+        if (mask.at<uchar>(it.second.first) != 0)
         {
             forw_pts.push_back(it.second.first);
             ids.push_back(it.second.second.first);
@@ -165,10 +164,10 @@ void FeatureTracker::readImage(const cv::Mat &_img, const cv::Mat &_mask, double
 
     if (PUB_THIS_FRAME)
     {
-        rejectWithF();
+        rejectWithH();
         ROS_DEBUG("set mask begins");
         TicToc t_m;
-        setMask();
+        setMask(_mask);
         ROS_DEBUG("set mask costs %fms", t_m.toc());
 
         ROS_DEBUG("detect feature begins");
@@ -202,11 +201,11 @@ void FeatureTracker::readImage(const cv::Mat &_img, const cv::Mat &_mask, double
     prev_time = cur_time;
 }
 
-void FeatureTracker::rejectWithF()
+void FeatureTracker::rejectWithH()
 {
-    if (forw_pts.size() >= 8)
+    if (forw_pts.size() >= 4)
     {
-        ROS_DEBUG("FM ransac begins");
+        ROS_DEBUG("HM ransac begins");
         TicToc t_f;
         vector<cv::Point2f> un_cur_pts(cur_pts.size()), un_forw_pts(forw_pts.size());
         for (unsigned int i = 0; i < cur_pts.size(); i++)
@@ -223,9 +222,27 @@ void FeatureTracker::rejectWithF()
             un_forw_pts[i] = cv::Point2f(tmp_p.x(), tmp_p.y());
         }
 
-        vector<uchar> status;
-        cv::findFundamentalMat(un_cur_pts, un_forw_pts, cv::FM_RANSAC, F_THRESHOLD, 0.99, status);
+        vector<uchar> status(un_cur_pts.size());
+        //cv::findFundamentalMat(un_cur_pts, un_forw_pts, cv::FM_RANSAC, F_THRESHOLD, 0.99, status);
         //cv::findHomography(un_cur_pts, un_forw_pts, cv::RANSAC, 3, status);
+
+        map<int, vector<cv::Point2f>> pid_un_cur_pts, pid_un_forw_pts;
+        map<pair<int,int>, int> new_ids_to_old;
+        for(uint i = 0; i < un_cur_pts.size(); i++)
+        {
+            pid_un_cur_pts[plane_ids[i]].push_back(un_cur_pts[i]);
+            pid_un_forw_pts[plane_ids[i]].push_back(un_forw_pts[i]);
+            new_ids_to_old[make_pair(plane_ids[i], pid_un_cur_pts[plane_ids[i]].size()-1)] = i;
+        }
+
+        for(auto &imap : pid_un_cur_pts)
+        {
+            vector<uchar> pid_status;
+            cv::findHomography(pid_un_cur_pts[imap.first], pid_un_forw_pts[imap.first], cv::RANSAC, 1.0, pid_status, 2000, 0.99);
+            for(int i = 0; i < pid_status.size(); i++)
+                status[new_ids_to_old[make_pair(imap.first, i)]] = pid_status[i];
+        }
+
         int size_a = cur_pts.size();
         reduceVector(prev_pts, status);
         reduceVector(cur_pts, status);
diff --git a/feature_tracker/src/feature_tracker.h b/feature_tracker/src/feature_tracker.h
index 5db3810..72cc8d8 100644
--- a/feature_tracker/src/feature_tracker.h
+++ b/feature_tracker/src/feature_tracker.h
@@ -32,7 +32,7 @@ class FeatureTracker
 
     void readImage(const cv::Mat &_img, const cv::Mat &_mask, double _cur_time);
 
-    void setMask();
+    void setMask(const cv::Mat &_mask);
 
     void addPoints(const cv::Mat &_mask);
 
@@ -42,7 +42,7 @@ class FeatureTracker
 
     void showUndistortion(const string &name);
 
-    void rejectWithF();
+    void rejectWithH();
 
     void undistortedPoints();
 
-- 
2.17.1


From 911c4c709cd356869c9a3394bb3a2cf4602de65c Mon Sep 17 00:00:00 2001
From: Karnik Ram <karnikram@gmail.com>
Date: Fri, 12 Feb 2021 10:58:47 +0530
Subject: [PATCH 37/42] Revert to airsim spatial extrinsics

---
 config/hvins_airsim_config.yaml | 4 ++--
 1 file changed, 2 insertions(+), 2 deletions(-)

diff --git a/config/hvins_airsim_config.yaml b/config/hvins_airsim_config.yaml
index 7847070..f8e2908 100644
--- a/config/hvins_airsim_config.yaml
+++ b/config/hvins_airsim_config.yaml
@@ -33,14 +33,14 @@ extrinsicRotation: !!opencv-matrix
    rows: 3
    cols: 3
    dt: d
-   data: [-0.00017913,-0.00042042,0.9999999,0.99999996,-0.00023746, 0.00017903,0.00023739,0.99999988,0.00042046] #[0,0,1,1,0,0,0,1,0] 
+   data: [0,0,1,1,0,0,0,1,0] #[-0.00017913,-0.00042042,0.9999999,0.99999996,-0.00023746, 0.00017903,0.00023739,0.99999988,0.00042046] #[0,0,1,1,0,0,0,1,0] 
 
 #Translation from camera frame to imu frame, imu^T_cam
 extrinsicTranslation: !!opencv-matrix
    rows: 3
    cols: 1
    dt: d
-   data: [0.49118794, 0.02176473, 0.01374164] #[0.50,0,0]
+   data: [0.50, 0, 0] #[0.49118794, 0.02176473, 0.01374164] #[0.50,0,0]
 
 #feature traker parameters
 max_cnt: 250          # max feature number in feature tracking
-- 
2.17.1


From 592768ea351956ff4a573292e78bc67449438db2 Mon Sep 17 00:00:00 2001
From: Karnik Ram <karnikram@gmail.com>
Date: Sun, 14 Feb 2021 12:48:22 +0530
Subject: [PATCH 38/42] Handle possible decomposeH exception

---
 vins_estimator/src/initial/solve_5pts.cpp | 29 +++++++++++++----------
 1 file changed, 17 insertions(+), 12 deletions(-)

diff --git a/vins_estimator/src/initial/solve_5pts.cpp b/vins_estimator/src/initial/solve_5pts.cpp
index f7aa380..bfba3f3 100644
--- a/vins_estimator/src/initial/solve_5pts.cpp
+++ b/vins_estimator/src/initial/solve_5pts.cpp
@@ -259,11 +259,14 @@ bool MotionEstimator::solveRelativeHRT(const vector<pair<Vector3d, Vector3d>> &c
         mean_l(1) /= int(inlier_count);
 
         Eigen::Matrix4d est_Tr;
-        Eigen::Vector3d est_n;
+        Eigen::Vector3d est_n(0,0,0);
         decomposeH(H, K, R_imu, TrIC, mean_l, est_Tr, est_n);
         Rotation = est_Tr.block(0,0,3,3);
         Translation = est_Tr.block(0,3,3,1);
         n = est_n;
+        if(n.isZero())
+            return false;
+
         return true;
     }
     return false;
@@ -295,7 +298,6 @@ void MotionEstimator::decomposeH(const cv::Mat &H, const cv::Mat &K, const Matri
             //Tr = TrIC * Tr * TrIC.inverse();
             Tr = Tr.inverse().eval();
 
-            Vector3d e3(0, 0, 1);
             Vector3d n;
             cv::cv2eigen(cv_ns[i], n);
             n.normalize();
@@ -306,18 +308,21 @@ void MotionEstimator::decomposeH(const cv::Mat &H, const cv::Mat &K, const Matri
             }
         }
 
-        vector<double> rot_diff;
-        for(size_t i = 0; i < positive_depth_transforms.size(); i++)
+        if(positive_depth_transforms.size() > 0)
         {
-            Eigen::Matrix4d Tr = TrIC * positive_depth_transforms[i] * TrIC.inverse();
-            Eigen::Matrix3d R = Tr.block(0,0,3,3);
-            double f = (R.transpose()*R_imu - MatrixXd::Identity(3,3)).norm();
-            rot_diff.push_back(f);
-        }
+            vector<double> rot_diff;
+            for(size_t i = 0; i < positive_depth_transforms.size(); i++)
+            {
+                Eigen::Matrix4d Tr = TrIC * positive_depth_transforms[i] * TrIC.inverse();
+                Eigen::Matrix3d R = Tr.block(0,0,3,3);
+                double f = (R.transpose()*R_imu - MatrixXd::Identity(3,3)).norm();
+                rot_diff.push_back(f);
+            }
 
-        int min_index = std::min_element(rot_diff.begin(), rot_diff.end()) - rot_diff.begin();
-        est_Tr = positive_depth_transforms[min_index];
-        est_n = positive_depth_normals[min_index];
+            int min_index = std::min_element(rot_diff.begin(), rot_diff.end()) - rot_diff.begin();
+            est_Tr = positive_depth_transforms[min_index];
+            est_n = positive_depth_normals[min_index];
+        }
     }
 
     else
-- 
2.17.1


From 1d0449b500e822224680d90503fcf785a2b28ab2 Mon Sep 17 00:00:00 2001
From: Karnik Ram <karnikram@gmail.com>
Date: Sun, 14 Feb 2021 12:48:49 +0530
Subject: [PATCH 39/42] Move plane variables to camera frame properly

---
 vins_estimator/src/estimator.cpp | 4 ++--
 vins_estimator/src/estimator.h   | 2 ++
 2 files changed, 4 insertions(+), 2 deletions(-)

diff --git a/vins_estimator/src/estimator.cpp b/vins_estimator/src/estimator.cpp
index d4ec043..86033e9 100644
--- a/vins_estimator/src/estimator.cpp
+++ b/vins_estimator/src/estimator.cpp
@@ -618,11 +618,11 @@ void Estimator::initializeNewPlanes()
                     if(average_parallax * 460 > 30 && m_estimator.solveRelativeHRT(corres, R_imu, TrIC, est_R, est_t, est_n))
                     {
                         // Transform est_n to global frame
-                        est_n = Rs[i] * est_n;
+                        est_n = ric[0].transpose() * Rs[i] * ric[0] * est_n;
                         para_N[plane_id] = {est_n(0), est_n(1), est_n(2)};
 
                         // Estimate plane d using known metric t from vio 
-                        vi_t = Rs[i].transpose() * (Ps[WINDOW_SIZE - 1] - Ps[i]);
+                        vi_t = ric[0].transpose() * Rs[i].transpose() * (Ps[WINDOW_SIZE - 1] - Ps[i]);
                         para_d[plane_id] = {(1.0*vi_t.norm()/est_t.norm())};
                         init_pids.push_back(plane_id);
                         ROS_INFO("Initialized plane %d features", plane_id);
diff --git a/vins_estimator/src/estimator.h b/vins_estimator/src/estimator.h
index e794866..6295758 100644
--- a/vins_estimator/src/estimator.h
+++ b/vins_estimator/src/estimator.h
@@ -117,6 +117,8 @@ class Estimator
     double para_Retrive_Pose[SIZE_POSE];
     double para_Td[1][1];
     double para_Tr[1][1];
+    
+    // In global camera frame (c_0)
     map<int, array<double,3>> para_N;
     map<int, array<double,1>> para_d;
 
-- 
2.17.1


From fe8857b092935da13daeee267612bc1a6e6c11bf Mon Sep 17 00:00:00 2001
From: Karnik Ram <karnikram@gmail.com>
Date: Sun, 14 Feb 2021 19:50:16 +0530
Subject: [PATCH 40/42] Transform d variable between frames properly

---
 vins_estimator/src/estimator.cpp              |  7 +++---
 vins_estimator/src/factor/homography_factor.h | 24 ++++++++++++++-----
 2 files changed, 22 insertions(+), 9 deletions(-)

diff --git a/vins_estimator/src/estimator.cpp b/vins_estimator/src/estimator.cpp
index 86033e9..26836fc 100644
--- a/vins_estimator/src/estimator.cpp
+++ b/vins_estimator/src/estimator.cpp
@@ -621,9 +621,10 @@ void Estimator::initializeNewPlanes()
                         est_n = ric[0].transpose() * Rs[i] * ric[0] * est_n;
                         para_N[plane_id] = {est_n(0), est_n(1), est_n(2)};
 
-                        // Estimate plane d using known metric t from vio 
-                        vi_t = ric[0].transpose() * Rs[i].transpose() * (Ps[WINDOW_SIZE - 1] - Ps[i]);
-                        para_d[plane_id] = {(1.0*vi_t.norm()/est_t.norm())};
+                        // Estimate plane d (in global frame) using known metric t from vio 
+                        vi_t = (Ps[WINDOW_SIZE - 1] - Ps[i]);
+                        double di = (1.0*vi_t.norm())/est_t.norm();
+                        para_d[plane_id] = {di + (ric[0].transpose() * Ps[i]).dot(est_n)};
                         init_pids.push_back(plane_id);
                         ROS_INFO("Initialized plane %d features", plane_id);
                         break;
diff --git a/vins_estimator/src/factor/homography_factor.h b/vins_estimator/src/factor/homography_factor.h
index 7107036..f5eb3dc 100644
--- a/vins_estimator/src/factor/homography_factor.h
+++ b/vins_estimator/src/factor/homography_factor.h
@@ -7,7 +7,7 @@ struct HomographyFactor
     HomographyFactor(const Eigen::Vector3d &_pts_i, const Eigen::Vector3d &_pts_j) : pts_i(_pts_i), pts_j(_pts_j) {}
 
     template <typename T>
-        bool operator()(const T* const pose_i, const T* const pose_j, const T* const para_n, const T* const para_inv_depth, const T* const ex_pose, 
+        bool operator()(const T* const pose_i, const T* const pose_j, const T* const para_n, const T* const para_depth, const T* const ex_pose, 
         T* residuals) const
         {
             Eigen::Map<const Eigen::Matrix<T, 3, 1>> pi(pose_i);
@@ -24,17 +24,29 @@ struct HomographyFactor
 
             Eigen::Matrix<T, 3, 1> n;
             n << para_n[0], para_n[1], para_n[2];
-            Eigen::Matrix<T, 3, 1> n_imu_1 = qic*n;// + tic;
-            Eigen::Matrix<T, 3, 1> n_imu_i = qi.inverse()*n_imu_1;// - qi.inverse()*pi;
 
-            Eigen::Map<const Eigen::Matrix<T, 1, 1>> inv_depth(para_inv_depth);
+            // transform camera normal to imu normal
+            Eigen::Matrix<T, 3, 1> n_imu_0 = qic*n;// + tic;
+
+            // transform imu 0 normal to imu i normal
+            Eigen::Matrix<T, 3, 1> n_imu_i = qi.inverse()*n_imu_0;// - qi.inverse()*pi;
+
+            Eigen::Map<const Eigen::Matrix<T, 1, 1>> depth(para_depth);
 
             Eigen::Quaternion<T> qji = qj.inverse() * qi;
             Eigen::Matrix<T, 3, 1> tji = qj.inverse() * (pi - pj);
-            Eigen::Matrix<T, 1, 1> di;
-            di(0,0) = inv_depth(0,0) - pi.dot(n_imu_i);
+            Eigen::Matrix<T, 1, 1> di, di0;
+
+            // convert camera depth to imu frame
+            di0(0,0) = depth(0,0) + tic.dot(n_imu_0);
+            // convert imu 0 depth to imu i depth
+            di(0,0) = di0(0,0) - pi.dot(n_imu_0);
+
             Eigen::Matrix<T, 3, 1> pts_imu_i = qic * pts_i.cast<T>() + tic;
+
+            // homography mapping
             Eigen::Matrix<T, 3, 1> pts_imu_j = qji * pts_imu_i + (tji*(1.0/di(0,0)) * n_imu_i.transpose()) * pts_imu_i;
+
             Eigen::Matrix<T, 3, 1> pts_cam_j = qic.inverse() * (pts_imu_j - tic);
 
             pts_cam_j = (pts_cam_j / pts_cam_j[2]);
-- 
2.17.1


From c5fa6e1369311dc5f762802c62a201590b9a5a34 Mon Sep 17 00:00:00 2001
From: Karnik Ram <karnikram@gmail.com>
Date: Sun, 21 Feb 2021 17:07:23 +0530
Subject: [PATCH 41/42] Modify benchmark publisher

---
 benchmark_publisher/launch/publish.launch     |  4 +-
 .../src/benchmark_publisher_node.cpp          | 27 +++-------
 config/vins_rviz_config.rviz                  | 49 ++++++++++++++-----
 .../launch/playback_vins_airsim.launch        |  3 ++
 4 files changed, 49 insertions(+), 34 deletions(-)

diff --git a/benchmark_publisher/launch/publish.launch b/benchmark_publisher/launch/publish.launch
index 5e066fa..5d52c78 100644
--- a/benchmark_publisher/launch/publish.launch
+++ b/benchmark_publisher/launch/publish.launch
@@ -1,9 +1,9 @@
 <launch>
 <!--MH_01_easy MH_02_easy MH_03_medium MH_04_difficult MH_05_difficult V1_01_easy V1_02_medium V1_03_difficult V2_01_easy V2_02_medium V2_03_difficult  -->
-	<arg name="sequence_name" default = "MH_01_easy" />
+	<arg name="sequence_name" default = "C4" />
 
     <node name="benchmark_publisher" pkg="benchmark_publisher" type="benchmark_publisher" output="screen">
-        <param name="data_name" type="string" value="$(find benchmark_publisher)/config/$(arg sequence_name)/data.csv" />
+        <param name="data_name" type="string" value="/home/karnik/dataset/airsim/CustomWarehouse/sine_tests/final2/c4_new/gt_data.txt" />
         <remap from="~estimated_odometry" to="/vins_estimator/odometry" />
     </node>
 <!--
diff --git a/benchmark_publisher/src/benchmark_publisher_node.cpp b/benchmark_publisher/src/benchmark_publisher_node.cpp
index c405c87..04e5d0f 100644
--- a/benchmark_publisher/src/benchmark_publisher_node.cpp
+++ b/benchmark_publisher/src/benchmark_publisher_node.cpp
@@ -11,7 +11,7 @@
 using namespace std;
 using namespace Eigen;
 
-const int SKIP = 50;
+const int SKIP = 100;
 string benchmark_output_path;
 string estimate_output_path;
 template <typename T>
@@ -34,22 +34,16 @@ struct Data
 {
     Data(FILE *f)
     {
-        if (fscanf(f, " %lf,%f,%f,%f,%f,%f,%f,%f,%f,%f,%f,%f,%f,%f,%f,%f,%f", &t,
+        if (fscanf(f, " %lf %f %f %f %f %f %f %f", &t,
                &px, &py, &pz,
-               &qw, &qx, &qy, &qz,
-               &vx, &vy, &vz,
-               &wx, &wy, &wz,
-               &ax, &ay, &az) != EOF)
+               &qx, &qy, &qz, &qw) != EOF)
         {
-            t /= 1e9;
+            //t /= 1e9;
         }
     }
     double t;
     float px, py, pz;
     float qw, qx, qy, qz;
-    float vx, vy, vz;
-    float wx, wy, wz;
-    float ax, ay, az;
 };
 int idx = 1;
 vector<Data> benchmark;
@@ -65,7 +59,6 @@ tf::Transform trans;
 
 void odom_callback(const nav_msgs::OdometryConstPtr &odom_msg)
 {
-    //ROS_INFO("odom callback!");
     if (odom_msg->header.stamp.toSec() > benchmark.back().t)
       return;
   
@@ -109,12 +102,6 @@ void odom_callback(const nav_msgs::OdometryConstPtr &odom_msg)
     odometry.pose.pose.orientation.y = tmp_R.y();
     odometry.pose.pose.orientation.z = tmp_R.z();
 
-    Vector3d tmp_V = baseRgt * Vector3d{benchmark[idx - 1].vx,
-                                        benchmark[idx - 1].vy,
-                                        benchmark[idx - 1].vz};
-    odometry.twist.twist.linear.x = tmp_V.x();
-    odometry.twist.twist.linear.y = tmp_V.y();
-    odometry.twist.twist.linear.z = tmp_V.z();
     pub_odom.publish(odometry);
 
     geometry_msgs::PoseStamped pose_stamped;
@@ -130,9 +117,9 @@ int main(int argc, char **argv)
     ros::init(argc, argv, "benchmark_publisher");
     ros::NodeHandle n("~");
 
-    string csv_file = readParam<string>(n, "data_name");
-    std::cout << "load ground truth " << csv_file << std::endl;
-    FILE *f = fopen(csv_file.c_str(), "r");
+    string txt_file = readParam<string>(n, "data_name");
+    std::cout << "load ground truth " << txt_file << std::endl;
+    FILE *f = fopen(txt_file.c_str(), "r");
     if (f==NULL)
     {
       ROS_WARN("can't load ground truth; wrong path");
diff --git a/config/vins_rviz_config.rviz b/config/vins_rviz_config.rviz
index e0c3a51..649da9d 100644
--- a/config/vins_rviz_config.rviz
+++ b/config/vins_rviz_config.rviz
@@ -4,7 +4,9 @@ Panels:
     Name: Displays
     Property Tree Widget:
       Expanded:
+        - /Global Options1
         - /VIO1
+        - /Path1
       Splitter Ratio: 0.4651159942150116
     Tree Height: 140
   - Class: rviz/Selection
@@ -44,7 +46,7 @@ Visualization Manager:
       Cell Size: 1
       Class: rviz/Grid
       Color: 130; 130; 130
-      Enabled: true
+      Enabled: false
       Line Style:
         Line Width: 0.029999999329447746
         Value: Lines
@@ -57,14 +59,14 @@ Visualization Manager:
       Plane: XY
       Plane Cell Count: 10
       Reference Frame: <Fixed Frame>
-      Value: true
+      Value: false
     - Class: rviz/Axes
-      Enabled: true
+      Enabled: false
       Length: 1
       Name: Axes
       Radius: 0.10000000149011612
       Reference Frame: <Fixed Frame>
-      Value: true
+      Value: false
     - Alpha: 1
       Buffer Length: 1
       Class: rviz/Path
@@ -454,9 +456,32 @@ Visualization Manager:
           Value: true
       Enabled: true
       Name: pose_graph
+    - Alpha: 1
+      Buffer Length: 1
+      Class: rviz/Path
+      Color: 164; 0; 0
+      Enabled: true
+      Head Diameter: 0.30000001192092896
+      Head Length: 0.20000000298023224
+      Length: 0.30000001192092896
+      Line Style: Lines
+      Line Width: 0.029999999329447746
+      Name: Path
+      Offset:
+        X: 0
+        Y: 0
+        Z: 0
+      Pose Color: 255; 85; 255
+      Pose Style: None
+      Radius: 0.029999999329447746
+      Shaft Diameter: 0.10000000149011612
+      Shaft Length: 0.10000000149011612
+      Topic: /benchmark_publisher/path
+      Unreliable: false
+      Value: true
   Enabled: true
   Global Options:
-    Background Color: 0; 0; 0
+    Background Color: 255; 255; 255
     Default Light: true
     Fixed Frame: world
     Frame Rate: 30
@@ -480,25 +505,25 @@ Visualization Manager:
   Views:
     Current:
       Class: rviz/XYOrbit
-      Distance: 117.1939697265625
+      Distance: 63.901485443115234
       Enable Stereo Rendering:
         Stereo Eye Separation: 0.05999999865889549
         Stereo Focal Distance: 1
         Swap Stereo Eyes: false
         Value: false
       Focal Point:
-        X: -2.70693039894104
-        Y: -1.2697441577911377
+        X: 7.038261890411377
+        Y: -13.610830307006836
         Z: 2.141062395821791e-5
       Focal Shape Fixed Size: true
       Focal Shape Size: 0.05000000074505806
       Invert Z Axis: false
       Name: Current View
       Near Clip Distance: 0.009999999776482582
-      Pitch: 0.01979677751660347
+      Pitch: 0.5597963333129883
       Target Frame: <Fixed Frame>
       Value: XYOrbit (rviz)
-      Yaw: 3.0572268962860107
+      Yaw: 4.052229404449463
     Saved: ~
 Window Geometry:
   Displays:
@@ -506,7 +531,7 @@ Window Geometry:
   Height: 734
   Hide Left Dock: false
   Hide Right Dock: true
-  QMainWindow State: 000000ff00000000fd00000004000000000000015600000243fc0200000010fb0000000a0049006d00610067006501000000280000013d0000000000000000fb0000001200530065006c0065006300740069006f006e00000001e10000009b0000005c00fffffffb0000001e0054006f006f006c002000500072006f007000650072007400690065007302000001ed000001df00000185000000a3fb000000120056006900650077007300200054006f006f02000001df000002110000018500000122fb000000200054006f006f006c002000500072006f0070006500720074006900650073003203000002880000011d000002210000017afb0000002000730065006c0065006300740069006f006e00200062007500660066006500720200000138000000aa0000023a00000294fb00000014005700690064006500530074006500720065006f02000000e6000000d2000003ee0000030bfb0000000c004b0069006e0065006300740200000186000001060000030c00000261fb0000001200720061007700200049006d0061006700650000000028000000300000000000000000fb00000012007200610077005f0069006d0061006700650000000028000000f90000001600fffffffb0000001a0074007200610063006b0065006400200069006d006100670065010000003d000001740000001600fffffffb00000020006c006f006f0070005f006d0061007400630068005f0069006d0061006700650000000121000000850000001600fffffffb000000100044006900730070006c00610079007301000001b7000000c9000000c900fffffffc000000280000011e0000000000fffffffa000000000100000002fb0000001200720061007700200049006d0061006700650000000000ffffffff0000000000000000fb0000001a0074007200610063006b0065006400200069006d0061006700650100000000000002370000000000000000fb0000001000410052005f0069006d0061006700650100000373000000160000000000000000fb0000001200720061007700200069006d006100670065010000038f000000160000000000000000000000010000020800000399fc0200000003fb0000001e0054006f006f006c002000500072006f00700065007200740069006500730100000041000000780000000000000000fc00000028000003990000000000fffffffaffffffff0100000002fb000000100044006900730070006c0061007900730000000000ffffffff0000015600fffffffb0000000a00560069006500770073000000023f0000016a0000010000fffffffb0000001200530065006c0065006300740069006f006e010000025a000000b200000000000000000000000200000490000000a9fc0100000001fb0000000a00560069006500770073030000004e00000080000002e10000019700000003000002eb0000003bfc0100000002fb0000000800540069006d00650100000000000002eb000002eb00fffffffb0000000800540069006d006501000000000000045000000000000000000000018f0000024300000004000000040000000800000008fc0000000100000002000000010000000a0054006f006f006c00730100000000ffffffff0000000000000000
+  QMainWindow State: 000000ff00000000fd00000004000000000000015600000243fc0200000010fb0000000a0049006d00610067006501000000280000013d0000000000000000fb0000001200530065006c0065006300740069006f006e00000001e10000009b0000005c00fffffffb0000001e0054006f006f006c002000500072006f007000650072007400690065007302000001ed000001df00000185000000a3fb000000120056006900650077007300200054006f006f02000001df000002110000018500000122fb000000200054006f006f006c002000500072006f0070006500720074006900650073003203000002880000011d000002210000017afb0000002000730065006c0065006300740069006f006e00200062007500660066006500720200000138000000aa0000023a00000294fb00000014005700690064006500530074006500720065006f02000000e6000000d2000003ee0000030bfb0000000c004b0069006e0065006300740200000186000001060000030c00000261fb0000001200720061007700200049006d0061006700650000000028000000300000000000000000fb00000012007200610077005f0069006d0061006700650000000028000000f90000001600fffffffb0000001a0074007200610063006b0065006400200069006d006100670065010000003d000001740000001600fffffffb00000020006c006f006f0070005f006d0061007400630068005f0069006d0061006700650000000121000000850000001600fffffffb000000100044006900730070006c00610079007301000001b7000000c9000000c900fffffffc000000280000011e0000000000fffffffa000000000100000002fb0000001200720061007700200049006d0061006700650000000000ffffffff0000000000000000fb0000001a0074007200610063006b0065006400200069006d0061006700650100000000000002370000000000000000fb0000001000410052005f0069006d0061006700650100000373000000160000000000000000fb0000001200720061007700200069006d006100670065010000038f000000160000000000000000000000010000020800000399fc0200000003fb0000001e0054006f006f006c002000500072006f00700065007200740069006500730100000041000000780000000000000000fc00000028000003990000000000fffffffaffffffff0100000002fb000000100044006900730070006c0061007900730000000000ffffffff0000015600fffffffb0000000a00560069006500770073000000023f0000016a0000010000fffffffb0000001200530065006c0065006300740069006f006e010000025a000000b200000000000000000000000200000490000000a9fc0100000001fb0000000a00560069006500770073030000004e00000080000002e10000019700000003000002a30000003bfc0100000002fb0000000800540069006d00650100000000000002a3000002eb00fffffffb0000000800540069006d00650100000000000004500000000000000000000001470000024300000004000000040000000800000008fc0000000100000002000000010000000a0054006f006f006c00730100000000ffffffff0000000000000000
   Selection:
     collapsed: false
   Time:
@@ -515,7 +540,7 @@ Window Geometry:
     collapsed: false
   Views:
     collapsed: true
-  Width: 747
+  Width: 675
   X: 685
   Y: 4
   loop_match_image:
diff --git a/vins_estimator/launch/playback_vins_airsim.launch b/vins_estimator/launch/playback_vins_airsim.launch
index 9925a21..972de2a 100644
--- a/vins_estimator/launch/playback_vins_airsim.launch
+++ b/vins_estimator/launch/playback_vins_airsim.launch
@@ -27,4 +27,7 @@
   <node name="rvizvisualisation" pkg="rviz" type="rviz" output="log" args="-d $(find vins_estimator)/../config/vins_rviz_config.rviz" />
 
  <node name="throttle" pkg="topic_tools" type="throttle" args="messages /imu 200 /imu_throttled"/>
+
+ <include file="$(find benchmark_publisher)/launch/publish.launch"/>
+
 </launch>
-- 
2.17.1


From 6283cbf075ecba7a2a188d06de362901cfd8429b Mon Sep 17 00:00:00 2001
From: Karnik Ram <karnikram@gmail.com>
Date: Sat, 27 Feb 2021 09:16:02 +0530
Subject: [PATCH 42/42] Viz largest plane

---
 config/vins_rviz_config.rviz                  | 10 +++---
 feature_tracker/src/feature_tracker_node.cpp  | 31 +++++++++++++++++--
 .../launch/playback_vins_airsim.launch        |  2 +-
 3 files changed, 34 insertions(+), 9 deletions(-)

diff --git a/config/vins_rviz_config.rviz b/config/vins_rviz_config.rviz
index 649da9d..2d6da66 100644
--- a/config/vins_rviz_config.rviz
+++ b/config/vins_rviz_config.rviz
@@ -528,10 +528,10 @@ Visualization Manager:
 Window Geometry:
   Displays:
     collapsed: false
-  Height: 734
+  Height: 711
   Hide Left Dock: false
   Hide Right Dock: true
-  QMainWindow State: 000000ff00000000fd00000004000000000000015600000243fc0200000010fb0000000a0049006d00610067006501000000280000013d0000000000000000fb0000001200530065006c0065006300740069006f006e00000001e10000009b0000005c00fffffffb0000001e0054006f006f006c002000500072006f007000650072007400690065007302000001ed000001df00000185000000a3fb000000120056006900650077007300200054006f006f02000001df000002110000018500000122fb000000200054006f006f006c002000500072006f0070006500720074006900650073003203000002880000011d000002210000017afb0000002000730065006c0065006300740069006f006e00200062007500660066006500720200000138000000aa0000023a00000294fb00000014005700690064006500530074006500720065006f02000000e6000000d2000003ee0000030bfb0000000c004b0069006e0065006300740200000186000001060000030c00000261fb0000001200720061007700200049006d0061006700650000000028000000300000000000000000fb00000012007200610077005f0069006d0061006700650000000028000000f90000001600fffffffb0000001a0074007200610063006b0065006400200069006d006100670065010000003d000001740000001600fffffffb00000020006c006f006f0070005f006d0061007400630068005f0069006d0061006700650000000121000000850000001600fffffffb000000100044006900730070006c00610079007301000001b7000000c9000000c900fffffffc000000280000011e0000000000fffffffa000000000100000002fb0000001200720061007700200049006d0061006700650000000000ffffffff0000000000000000fb0000001a0074007200610063006b0065006400200069006d0061006700650100000000000002370000000000000000fb0000001000410052005f0069006d0061006700650100000373000000160000000000000000fb0000001200720061007700200069006d006100670065010000038f000000160000000000000000000000010000020800000399fc0200000003fb0000001e0054006f006f006c002000500072006f00700065007200740069006500730100000041000000780000000000000000fc00000028000003990000000000fffffffaffffffff0100000002fb000000100044006900730070006c0061007900730000000000ffffffff0000015600fffffffb0000000a00560069006500770073000000023f0000016a0000010000fffffffb0000001200530065006c0065006300740069006f006e010000025a000000b200000000000000000000000200000490000000a9fc0100000001fb0000000a00560069006500770073030000004e00000080000002e10000019700000003000002a30000003bfc0100000002fb0000000800540069006d00650100000000000002a3000002eb00fffffffb0000000800540069006d00650100000000000004500000000000000000000001470000024300000004000000040000000800000008fc0000000100000002000000010000000a0054006f006f006c00730100000000ffffffff0000000000000000
+  QMainWindow State: 000000ff00000000fd0000000400000000000001fb0000022cfc0200000010fb0000000a0049006d00610067006501000000280000013d0000000000000000fb0000001200530065006c0065006300740069006f006e00000001e10000009b0000005c00fffffffb0000001e0054006f006f006c002000500072006f007000650072007400690065007302000001ed000001df00000185000000a3fb000000120056006900650077007300200054006f006f02000001df000002110000018500000122fb000000200054006f006f006c002000500072006f0070006500720074006900650073003203000002880000011d000002210000017afb0000002000730065006c0065006300740069006f006e00200062007500660066006500720200000138000000aa0000023a00000294fb00000014005700690064006500530074006500720065006f02000000e6000000d2000003ee0000030bfb0000000c004b0069006e0065006300740200000186000001060000030c00000261fb0000001200720061007700200049006d0061006700650000000028000000300000000000000000fb00000012007200610077005f0069006d0061006700650000000028000000f90000001600fffffffb0000001a0074007200610063006b0065006400200069006d006100670065010000003d0000015d0000001600fffffffb00000020006c006f006f0070005f006d0061007400630068005f0069006d0061006700650000000121000000850000001600fffffffb000000100044006900730070006c00610079007301000001a0000000c9000000c900fffffffc000000280000011e0000000000fffffffa000000000100000002fb0000001200720061007700200049006d0061006700650000000000ffffffff0000000000000000fb0000001a0074007200610063006b0065006400200069006d0061006700650100000000000002370000000000000000fb0000001000410052005f0069006d0061006700650100000373000000160000000000000000fb0000001200720061007700200069006d006100670065010000038f000000160000000000000000000000010000020800000399fc0200000003fb0000001e0054006f006f006c002000500072006f00700065007200740069006500730100000041000000780000000000000000fc00000028000003990000000000fffffffaffffffff0100000002fb000000100044006900730070006c0061007900730000000000ffffffff0000015600fffffffb0000000a00560069006500770073000000023f0000016a0000010000fffffffb0000001200530065006c0065006300740069006f006e010000025a000000b200000000000000000000000200000490000000a9fc0100000001fb0000000a00560069006500770073030000004e00000080000002e10000019700000003000005130000003bfc0100000002fb0000000800540069006d0065010000000000000513000002eb00fffffffb0000000800540069006d00650100000000000004500000000000000000000003120000022c00000004000000040000000800000008fc0000000100000002000000010000000a0054006f006f006c00730100000000ffffffff0000000000000000
   Selection:
     collapsed: false
   Time:
@@ -540,9 +540,9 @@ Window Geometry:
     collapsed: false
   Views:
     collapsed: true
-  Width: 675
-  X: 685
-  Y: 4
+  Width: 1299
+  X: 67
+  Y: 27
   loop_match_image:
     collapsed: false
   raw_image:
diff --git a/feature_tracker/src/feature_tracker_node.cpp b/feature_tracker/src/feature_tracker_node.cpp
index ba64fed..96b37fd 100644
--- a/feature_tracker/src/feature_tracker_node.cpp
+++ b/feature_tracker/src/feature_tracker_node.cpp
@@ -176,11 +176,36 @@ void callback(const sensor_msgs::ImageConstPtr &img_msg, const sensor_msgs::Imag
             ptr = cv_bridge::cvtColor(ptr, sensor_msgs::image_encodings::BGR8);
             //cv::Mat stereo_img(ROW * NUM_OF_CAM, COL, CV_8UC3);
             cv::Mat stereo_img = ptr->image;
+            cv::Mat mask_img = mask_ptr->image;
+            std::vector<int> pids = trackerData[0].plane_ids;
+
+            std::set<int> unique_pids(pids.begin(), pids.end());
+            std::map<int, int> plane_counts;
+            for(auto &pid : unique_pids)
+                plane_counts[pid] = 0;
+
+            for(auto &pid : pids)
+                plane_counts[pid]++;
+
+            int largest_count = 0, largest_pid;
+            for(auto &plane_count : plane_counts)
+            {   
+                if(plane_count.second > largest_count)
+                {
+                    largest_count = plane_count.second;
+                    largest_pid = plane_count.first;
+                }
+            }
+    
+            cv::Mat mask = mask_img == largest_pid;
+            cv::Mat mask_viz(ROW, COL, CV_8UC3, cv::Scalar(0,0,0));
+            mask_viz.setTo(cv::Scalar(0,255,0), mask);
 
             for (int i = 0; i < NUM_OF_CAM; i++)
             {
                 cv::Mat tmp_img = stereo_img.rowRange(i * ROW, (i + 1) * ROW);
                 cv::cvtColor(show_img, tmp_img, CV_GRAY2RGB);
+                cv::addWeighted(tmp_img, 1.0, mask_viz, 0.3, 0.0, tmp_img);
 
                 for (unsigned int j = 0; j < trackerData[i].cur_pts.size(); j++)
                 {
@@ -197,9 +222,9 @@ void callback(const sensor_msgs::ImageConstPtr &img_msg, const sensor_msgs::Imag
                     trackerData[i].m_camera->spaceToPlane(tmp_prev_un_pts, tmp_prev_uv);
                     cv::line(tmp_img, trackerData[i].cur_pts[j], cv::Point2f(tmp_prev_uv.x(), tmp_prev_uv.y()), cv::Scalar(255 , 0, 0), 1 , 8, 0);
                     */
-                    char name[10];
-                    sprintf(name, "%d", trackerData[i].plane_ids[j]);
-                    cv::putText(tmp_img, name, trackerData[i].cur_pts[j], cv::FONT_HERSHEY_SIMPLEX, 0.5, cv::Scalar(0, 0, 0));
+                    //char name[10];
+                    //sprintf(name, "%d", trackerData[i].plane_ids[j]);
+                    //cv::putText(tmp_img, name, trackerData[i].cur_pts[j], cv::FONT_HERSHEY_SIMPLEX, 0.5, cv::Scalar(0, 0, 0));
                 }
             }
             //cv::imshow("vis", stereo_img);
diff --git a/vins_estimator/launch/playback_vins_airsim.launch b/vins_estimator/launch/playback_vins_airsim.launch
index 972de2a..49b4b1e 100644
--- a/vins_estimator/launch/playback_vins_airsim.launch
+++ b/vins_estimator/launch/playback_vins_airsim.launch
@@ -28,6 +28,6 @@
 
  <node name="throttle" pkg="topic_tools" type="throttle" args="messages /imu 200 /imu_throttled"/>
 
- <include file="$(find benchmark_publisher)/launch/publish.launch"/>
+ <!--<include file="$(find benchmark_publisher)/launch/publish.launch"/>-->
 
 </launch>
-- 
2.17.1

